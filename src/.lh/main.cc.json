{
    "sourceFile": "main.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1690175170853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1690175170853,
            "name": "Commit-0",
            "content": "// Copyright 2021 DeepMind Technologies Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <chrono>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <memory>\n#include <mutex>\n#include <new>\n#include <string>\n#include <thread>\n#include <type_traits>\n#include <vector>\n\n#include <mujoco/mujoco.h>\n#include \"glfw_adapter.h\"\n#include \"simulate.h\"\n#include \"array_safety.h\"\n#include \"controller.h\"\n\n#define MUJOCO_PLUGIN_DIR \"mujoco_plugin\"\n\nextern \"C\" {\n#if defined(_WIN32) || defined(__CYGWIN__)\n  #include <windows.h>\n#else\n  #if defined(__APPLE__)\n    #include <mach-o/dyld.h>\n  #endif\n  #include <sys/errno.h>\n  #include <unistd.h>\n#endif\n}\n\n#define JDOF 7\nCController Control;\n\nnamespace {\nnamespace mj = ::mujoco;\nnamespace mju = ::mujoco::sample_util;\n\n// constants\nconst double syncMisalign = 0.1;        // maximum mis-alignment before re-sync (simulation seconds)\nconst double simRefreshFraction = 0.7;  // fraction of refresh available for simulation\nconst int kErrorLength = 1024;          // load error string length\n\ndouble goal_trasnformation_matrix[16];\n\n// model and data\nmjModel* m = nullptr;\nmjData* d = nullptr;\n\n// control noise variables\nmjtNum* ctrlnoise = nullptr;\n\nusing Seconds = std::chrono::duration<double>;\n\n\n//---------------------------------------- plugin handling -----------------------------------------\n\n// return the path to the directory containing the current executable\n// used to determine the location of auto-loaded plugin libraries\nstd::string getExecutableDir() {\n#if defined(_WIN32) || defined(__CYGWIN__)\n  constexpr char kPathSep = '\\\\';\n  std::string realpath = [&]() -> std::string {\n    std::unique_ptr<char[]> realpath(nullptr);\n    DWORD buf_size = 128;\n    bool success = false;\n    while (!success) {\n      realpath.reset(new(std::nothrow) char[buf_size]);\n      if (!realpath) {\n        std::cerr << \"cannot allocate memory to store executable path\\n\";\n        return \"\";\n      }\n\n      DWORD written = GetModuleFileNameA(nullptr, realpath.get(), buf_size);\n      if (written < buf_size) {\n        success = true;\n      } else if (written == buf_size) {\n        // realpath is too small, grow and retry\n        buf_size *=2;\n      } else {\n        std::cerr << \"failed to retrieve executable path: \" << GetLastError() << \"\\n\";\n        return \"\";\n      }\n    }\n    return realpath.get();\n  }();\n#else\n  constexpr char kPathSep = '/';\n#if defined(__APPLE__)\n  std::unique_ptr<char[]> buf(nullptr);\n  {\n    std::uint32_t buf_size = 0;\n    _NSGetExecutablePath(nullptr, &buf_size);\n    buf.reset(new char[buf_size]);\n    if (!buf) {\n      std::cerr << \"cannot allocate memory to store executable path\\n\";\n      return \"\";\n    }\n    if (_NSGetExecutablePath(buf.get(), &buf_size)) {\n      std::cerr << \"unexpected error from _NSGetExecutablePath\\n\";\n    }\n  }\n  const char* path = buf.get();\n#else\n  const char* path = \"/proc/self/exe\";\n#endif\n  std::string realpath = [&]() -> std::string {\n    std::unique_ptr<char[]> realpath(nullptr);\n    std::uint32_t buf_size = 128;\n    bool success = false;\n    while (!success) {\n      realpath.reset(new(std::nothrow) char[buf_size]);\n      if (!realpath) {\n        std::cerr << \"cannot allocate memory to store executable path\\n\";\n        return \"\";\n      }\n\n      std::size_t written = readlink(path, realpath.get(), buf_size);\n      if (written < buf_size) {\n        realpath.get()[written] = '\\0';\n        success = true;\n      } else if (written == -1) {\n        if (errno == EINVAL) {\n          // path is already not a symlink, just use it\n          return path;\n        }\n\n        std::cerr << \"error while resolving executable path: \" << strerror(errno) << '\\n';\n        return \"\";\n      } else {\n        // realpath is too small, grow and retry\n        buf_size *= 2;\n      }\n    }\n    return realpath.get();\n  }();\n#endif\n\n  if (realpath.empty()) {\n    return \"\";\n  }\n\n  for (std::size_t i = realpath.size() - 1; i > 0; --i) {\n    if (realpath.c_str()[i] == kPathSep) {\n      return realpath.substr(0, i);\n    }\n  }\n\n  // don't scan through the entire file system's root\n  return \"\";\n}\n\n\n\n// scan for libraries in the plugin directory to load additional plugins\nvoid scanPluginLibraries() {\n  // check and print plugins that are linked directly into the executable\n  int nplugin = mjp_pluginCount();\n  if (nplugin) {\n    std::printf(\"Built-in plugins:\\n\");\n    for (int i = 0; i < nplugin; ++i) {\n      std::printf(\"    %s\\n\", mjp_getPluginAtSlot(i)->name);\n    }\n  }\n\n  // define platform-specific strings\n#if defined(_WIN32) || defined(__CYGWIN__)\n  const std::string sep = \"\\\\\";\n#else\n  const std::string sep = \"/\";\n#endif\n\n\n  // try to open the ${EXECDIR}/plugin directory\n  // ${EXECDIR} is the directory containing the simulate binary itself\n  const std::string executable_dir = getExecutableDir();\n  if (executable_dir.empty()) {\n    return;\n  }\n\n  const std::string plugin_dir = getExecutableDir() + sep + MUJOCO_PLUGIN_DIR;\n  mj_loadAllPluginLibraries(\n      plugin_dir.c_str(), +[](const char* filename, int first, int count) {\n        std::printf(\"Plugins registered by library '%s':\\n\", filename);\n        for (int i = first; i < first + count; ++i) {\n          std::printf(\"    %s\\n\", mjp_getPluginAtSlot(i)->name);\n        }\n      });\n}\n\n\n//------------------------------------------- simulation -------------------------------------------\n\n\nmjModel* LoadModel(const char* file, mj::Simulate& sim) {\n  // this copy is needed so that the mju::strlen call below compiles\n  char filename[mj::Simulate::kMaxFilenameLength];\n  mju::strcpy_arr(filename, file);\n\n  // make sure filename is not empty\n  if (!filename[0]) {\n    return nullptr;\n  }\n\n  // load and compile\n  char loadError[kErrorLength] = \"\";\n  mjModel* mnew = 0;\n  if (mju::strlen_arr(filename)>4 &&\n      !std::strncmp(filename + mju::strlen_arr(filename) - 4, \".mjb\",\n                    mju::sizeof_arr(filename) - mju::strlen_arr(filename)+4)) {\n    mnew = mj_loadModel(filename, nullptr);\n    if (!mnew) {\n      mju::strcpy_arr(loadError, \"could not load binary model\");\n    }\n  } else {\n    mnew = mj_loadXML(filename, nullptr, loadError, mj::Simulate::kMaxFilenameLength);\n    // remove trailing newline character from loadError\n    if (loadError[0]) {\n      int error_length = mju::strlen_arr(loadError);\n      if (loadError[error_length-1] == '\\n') {\n        loadError[error_length-1] = '\\0';\n      }\n    }\n  }\n\n  mju::strcpy_arr(sim.loadError, loadError);\n\n  if (!mnew) {\n    std::printf(\"%s\\n\", loadError);\n    return nullptr;\n  }\n\n  // compiler warning: print and pause\n  if (loadError[0]) {\n    // mj_forward() below will print the warning message\n    std::printf(\"Model compiled, but simulation warning (paused):\\n  %s\\n\", loadError);\n    sim.run = 0;\n  }\n\n  return mnew;\n}\n\n// simulate in background thread (while rendering in main thread)\nvoid PhysicsLoop(mj::Simulate& sim) {\n  // cpu-sim syncronization point\n  std::chrono::time_point<mj::Simulate::Clock> syncCPU;\n  mjtNum syncSim = 0;\n  bool initialpos = true;\n\n  // run until asked to exit\n  while (!sim.exitrequest.load()) {\n    if (sim.droploadrequest.load()) {\n      mjModel* mnew = LoadModel(sim.dropfilename, sim);\n      sim.droploadrequest.store(false);\n\n      mjData* dnew = nullptr;\n      if (mnew) dnew = mj_makeData(mnew);\n      if (dnew) {\n        sim.load(sim.dropfilename, mnew, dnew);\n\n        mj_deleteData(d);\n        mj_deleteModel(m);\n\n        m = mnew;\n        d = dnew;\n        mj_forward(m, d);\n\n        // allocate ctrlnoise\n        free(ctrlnoise);\n        ctrlnoise = (mjtNum*) malloc(sizeof(mjtNum)*m->nu);\n        mju_zero(ctrlnoise, m->nu);\n      }\n    }\n\n    if (sim.uiloadrequest.load()) {\n      sim.uiloadrequest.fetch_sub(1);\n      mjModel* mnew = LoadModel(sim.filename, sim);\n      mjData* dnew = nullptr;\n      if (mnew) dnew = mj_makeData(mnew);\n      if (dnew) {\n        sim.load(sim.filename, mnew, dnew);\n\n        mj_deleteData(d);\n        mj_deleteModel(m);\n\n        m = mnew;\n        d = dnew;\n        mj_forward(m, d);\n\n        // allocate ctrlnoise\n        free(ctrlnoise);\n        ctrlnoise = static_cast<mjtNum*>(malloc(sizeof(mjtNum)*m->nu));\n        mju_zero(ctrlnoise, m->nu);\n      }\n    }\n\n    // sleep for 1 ms or yield, to let main thread run\n    //  yield results in busy wait - which has better timing but kills battery life\n    if (sim.run && sim.busywait) {\n      std::this_thread::yield();\n    } else {\n      std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n\n    {\n      // lock the sim mutex\n      const std::lock_guard<std::mutex> lock(sim.mtx);\n\n      // run only if model is present\n      if (m) {\n        // running\n        if (sim.run) {\n          // record cpu time at start of iteration\n          const auto startCPU = mj::Simulate::Clock::now();\n\n          // Control.read(d->time, d->qpos, d->qvel, d->ncon);\n          // Control.control_mujoco();\n          // Control.write(d->ctrl);\n\n          // for(int i = 0; i<50; i++)\n          // {\n          //   cout<<\"d->xpos[\"<<i<<\"] : \"<<d->xpos[i]<<endl;\n          // }\n\n          if(initialpos == true)\n          {\n            d->qpos[5] = 30.0 * DEG2RAD; // to avoid self collision\n            // d->qpos[9] = 0.0 * DEG2RAD; // to avoid self collision\n            initialpos = false;\n          }\n          \n          else\n          {\n            \n            for(int i = 0; i<4; i++)\n            {\n              for(int j = 0; j<4; j++)\n              {\n                if(j == 3)\n                {\n                  goal_trasnformation_matrix[i*4+j] = d->xpos[39+i];\n                }\n                else\n                {\n                  goal_trasnformation_matrix[i*4+j] = d->xmat[117+j+3*i];\n                }\n              }\n            }\n\n            // TaskControl.read(d->time, d->qpos, d->qvel, m->opt.timestep);\n            Control.read(d->time, d->qpos, d->qvel, d->ncon, goal_trasnformation_matrix);\n            Control.control_mujoco();\n            Control.write(d->ctrl);\n            // cout<<\"(\" <<d->ctrl[7]<<\",\"<<d->ctrl[8]<<\")  \"; \n          }\n          // Control.read(d->time, d->qpos, d->qvel, d->ncon);\n          // Control.control_mujoco();\n          // Control.write(d->ctrl);\n\n          // elapsed CPU and simulation time since last sync\n          const auto elapsedCPU = startCPU - syncCPU;\n          double elapsedSim = d->time - syncSim;\n\n          // inject noise\n          if (sim.ctrlnoisestd) {\n            // convert rate and scale to discrete time (Ornstein–Uhlenbeck)\n            mjtNum rate = mju_exp(-m->opt.timestep / mju_max(sim.ctrlnoiserate, mjMINVAL));\n            mjtNum scale = sim.ctrlnoisestd * mju_sqrt(1-rate*rate);\n\n            for (int i=0; i<m->nu; i++) {\n              // update noise\n              ctrlnoise[i] = rate * ctrlnoise[i] + scale * mju_standardNormal(nullptr);\n\n              // apply noise\n              d->ctrl[i] = ctrlnoise[i];\n            }\n          }\n\n          // requested slow-down factor\n          double slowdown = 100 / sim.percentRealTime[sim.realTimeIndex];\n\n          // misalignment condition: distance from target sim time is bigger than syncmisalign\n          bool misaligned =\n              mju_abs(Seconds(elapsedCPU).count()/slowdown - elapsedSim) > syncMisalign;\n\n          // out-of-sync (for any reason): reset sync times, step\n          // if (elapsedSim < 0 || elapsedCPU.count() < 0 || syncCPU.time_since_epoch().count() == 0 ||\n          //     misaligned || sim.speedChanged) {\n            // re-sync\n            syncCPU = startCPU;\n            syncSim = d->time;\n            sim.speedChanged = false;\n\n            // clear old perturbations, apply new\n            mju_zero(d->xfrc_applied, 6*m->nbody);\n            sim.applyposepertubations(0);  // move mocap bodies only\n            sim.applyforceperturbations();\n\n            // run single step, let next iteration deal with timing\n            mj_step(m, d);\n          // }\n\n          // in-sync: step until ahead of cpu\n        //   else {\n        //     bool measured = false;\n        //     mjtNum prevSim = d->time;\n\n        //     double refreshTime = simRefreshFraction/sim.refreshRate;\n\n        //     // step while sim lags behind cpu and within refreshTime\n        //     while (Seconds((d->time - syncSim)*slowdown) < mj::Simulate::Clock::now() - syncCPU &&\n        //            mj::Simulate::Clock::now() - startCPU < Seconds(refreshTime)) {\n        //       // measure slowdown before first step\n        //       if (!measured && elapsedSim) {\n        //         sim.measuredSlowdown =\n        //             std::chrono::duration<double>(elapsedCPU).count() / elapsedSim;\n        //         measured = true;\n        //       }\n\n        //       // clear old perturbations, apply new\n        //       mju_zero(d->xfrc_applied, 6*m->nbody);\n        //       sim.applyposepertubations(0);  // move mocap bodies only\n        //       sim.applyforceperturbations();\n\n        //       // call mj_step\n        //       mj_step(m, d);\n\n        //       // break if reset\n        //       if (d->time < prevSim) {\n        //         break;\n        //       }\n        //     }\n          }\n        // }\n\n        // paused\n        else {\n          // apply pose perturbation\n          sim.applyposepertubations(1);  // move mocap and dynamic bodies\n\n          // run mj_forward, to update rendering and joint sliders\n          mj_forward(m, d);\n        }\n      }\n    }  // release std::lock_guard<std::mutex>\n  }\n}\n}  // namespace\n\n//-------------------------------------- physics_thread --------------------------------------------\n\nvoid PhysicsThread(mj::Simulate* sim, const char* filename) {\n  // request loadmodel if file given (otherwise drag-and-drop)\n  if (filename != nullptr) {\n    m = LoadModel(filename, *sim);\n    if (m) d = mj_makeData(m);\n    if (d) {\n      sim->load(filename, m, d);\n      mj_forward(m, d);\n\n      // allocate ctrlnoise\n      free(ctrlnoise);\n      ctrlnoise = static_cast<mjtNum*>(malloc(sizeof(mjtNum)*m->nu));\n      mju_zero(ctrlnoise, m->nu);\n    }\n  }\n\n  PhysicsLoop(*sim);\n\n  // delete everything we allocated\n  free(ctrlnoise);\n  mj_deleteData(d);\n  mj_deleteModel(m);\n}\n\n//------------------------------------------ main --------------------------------------------------\n\n// machinery for replacing command line error by a macOS dialog box when running under Rosetta\n#if defined(__APPLE__) && defined(__AVX__)\nextern void DisplayErrorDialogBox(const char* title, const char* msg);\nstatic const char* rosetta_error_msg = nullptr;\n__attribute__((used, visibility(\"default\"))) extern \"C\" void _mj_rosettaError(const char* msg) {\n  rosetta_error_msg = msg;\n}\n#endif\n\n// run event loop\nint main(int argc, const char** argv) {\n  // display an error if running on macOS under Rosetta 2\n  // cout<<\"??\"<<endl;\n  char str[100] = \"../model/fr3.xml\"; // hand(xml)\n#if defined(__APPLE__) && defined(__AVX__)\n  if (rosetta_error_msg) {\n    DisplayErrorDialogBox(\"Rosetta 2 is not supported\", rosetta_error_msg);\n    std::exit(1);\n  }\n#endif\n\n  // print version, check compatibility\n  std::printf(\"MuJoCo version %s\\n\", mj_versionString());\n  if (mjVERSION_HEADER!=mj_version()) {\n    mju_error(\"Headers and library have different versions\");\n  }\n\n  // scan for libraries in the plugin directory to load additional plugins\n  scanPluginLibraries();\n\n  // simulate object encapsulates the UI\n  auto sim = std::make_unique<mj::Simulate>(\n      std::make_unique<mj::GlfwAdapter>());\n\n  const char* filename = nullptr;\n  \n  // if (argc >  1) {\n  //   filename = argv[1];\n  // }\n  // memcpy(filename, str, sizeof(str));\n  filename = str;\n  // start physics thread\n  std::thread physicsthreadhandle(&PhysicsThread, sim.get(), filename);\n\n  // start simulation UI loop (blocking call)\n  sim->renderloop();\n  physicsthreadhandle.join();\n\n  return 0;\n}\n"
        }
    ]
}