{
    "sourceFile": "simulate.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1691632344634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1691632344634,
            "name": "Commit-0",
            "content": "/*  Copyright Â© 2018, Roboti LLC\r\n\r\n    This file is licensed under the MuJoCo Resource License (the \"License\").\r\n    You may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n        https://www.roboti.us/resourcelicense.txt\r\n*/\r\n\r\n// #include \"mujoco200/include/mjxmacro.h\"\r\n// #include \"mujoco200/include/uitools.h\"\r\n#include \"../mujoco200/include/mjxmacro.h\"\r\n#include \"../mujoco200/include/uitools.h\"\r\n#include \"stdio.h\"\r\n#include \"string.h\"\r\n#include \"controller.h\"\r\n\r\n#include <thread>\r\n#include <mutex>\r\n#include <chrono>\r\n#include <iostream>\r\n\r\n#define JDOF 7\r\nusing namespace std;\r\n\r\n//-------------------------------- global -----------------------------------------------\r\n\r\n// constants\r\nconst int maxgeom = 5000;           // preallocated geom array in mjvScene\r\nconst double syncmisalign = 0.1;    // maximum time mis-alignment before re-sync\r\nconst double refreshfactor = 0.7;   // fraction of refresh available for simulation\r\n\r\n\r\n// model and data\r\nmjModel* m = NULL;\r\nmjData* d = NULL;\r\nchar filename[1000] = \"\";\r\n\r\n//controller\r\nCController Control;\r\n\r\n// abstract visualization\r\nmjvScene scn;\r\nmjvCamera cam;\r\nmjvOption vopt;\r\nmjvPerturb pert;\r\nmjvFigure figconstraint;\r\nmjvFigure figcost;\r\nmjvFigure figtimer;\r\nmjvFigure figsize;\r\nmjvFigure figsensor;\r\n\r\n\r\n// OpenGL rendering and UI\r\nGLFWvidmode vmode;\r\nint windowpos[2];\r\nint windowsize[2];\r\nmjrContext con;\r\nGLFWwindow* window = NULL;\r\nmjuiState uistate;\r\nmjUI ui0, ui1;\r\n\r\n\r\n// UI settings not contained in MuJoCo structures\r\nstruct\r\n{\r\n    // file\r\n    int exitrequest = 0;\r\n\r\n    // option\r\n    int spacing = 0;\r\n    int color = 0;\r\n    int font = 0;\r\n    int ui0 = 1;\r\n    int ui1 = 1;\r\n    int help = 0;\r\n    int info = 0;\r\n    int profiler = 0;\r\n    int sensor = 0;\r\n    int fullscreen = 0;\r\n    int vsync = 1;\r\n    int busywait = 0;\r\n\r\n    // simulation\r\n    int run = 1;\r\n    int key = 0;\r\n    int loadrequest = 0;\r\n\r\n    // watch\r\n    char field[mjMAXUITEXT] = \"qpos\";\r\n    int index = 0;\r\n\r\n    // physics: need sync\r\n    int disable[mjNDISABLE];\r\n    int enable[mjNENABLE];\r\n\r\n    // rendering: need sync\r\n    int camera = 0;\r\n} settings;\r\n\r\n\r\n// section ids\r\nenum\r\n{\r\n    // left ui\r\n    SECT_FILE = 0,\r\n    SECT_OPTION,\r\n    SECT_SIMULATION,\r\n    SECT_WATCH,\r\n    SECT_PHYSICS,\r\n    SECT_RENDERING,\r\n    SECT_GROUP,\r\n    NSECT0,\r\n\r\n    // right ui\r\n    SECT_JOINT = 0,\r\n    SECT_CONTROL,\r\n    NSECT1\r\n};\r\n\r\n\r\n// file section of UI\r\nconst mjuiDef defFile[] =\r\n{\r\n    {mjITEM_SECTION,   \"File\",          1, NULL,                    \"AF\"},\r\n    {mjITEM_BUTTON,    \"Save xml\",      2, NULL,                    \"\"},\r\n    {mjITEM_BUTTON,    \"Save mjb\",      2, NULL,                    \"\"},\r\n    {mjITEM_BUTTON,    \"Print model\",   2, NULL,                    \"CM\"},\r\n    {mjITEM_BUTTON,    \"Print data\",    2, NULL,                    \"CD\"},\r\n    {mjITEM_BUTTON,    \"Quit\",          1, NULL,                    \"CQ\"},\r\n    {mjITEM_END}\r\n};\r\n\r\n\r\n// option section of UI\r\nconst mjuiDef defOption[] =\r\n{\r\n    {mjITEM_SECTION,   \"Option\",        1, NULL,                    \"AO\"},\r\n    {mjITEM_SELECT,    \"Spacing\",       1, &settings.spacing,       \"Tight\\nWide\"},\r\n    {mjITEM_SELECT,    \"Color\",         1, &settings.color,         \"Default\\nOrange\\nWhite\\nBlack\"},\r\n    {mjITEM_SELECT,    \"Font\",          1, &settings.font,          \"50 %\\n100 %\\n150 %\\n200 %\\n250 %\\n300 %\"},\r\n    {mjITEM_CHECKINT,  \"Left UI (Tab)\", 1, &settings.ui0,           \" #258\"},\r\n    {mjITEM_CHECKINT,  \"Right UI\",      1, &settings.ui1,           \"S#258\"},\r\n    {mjITEM_CHECKINT,  \"Help\",          2, &settings.help,          \" #290\"},\r\n    {mjITEM_CHECKINT,  \"Info\",          2, &settings.info,          \" #291\"},\r\n    {mjITEM_CHECKINT,  \"Profiler\",      2, &settings.profiler,      \" #292\"},\r\n    {mjITEM_CHECKINT,  \"Sensor\",        2, &settings.sensor,        \" #293\"},\r\n#ifdef __APPLE__\r\n    {mjITEM_CHECKINT,  \"Fullscreen\",    0, &settings.fullscreen,    \" #294\"},\r\n#else\r\n    {mjITEM_CHECKINT,  \"Fullscreen\",    1, &settings.fullscreen,    \" #294\"},\r\n#endif\r\n    {mjITEM_CHECKINT,  \"Vertical Sync\", 1, &settings.vsync,         \" #295\"},\r\n    {mjITEM_CHECKINT,  \"Busy Wait\",     1, &settings.busywait,      \" #296\"},\r\n    {mjITEM_END}\r\n};\r\n\r\n\r\n// simulation section of UI\r\nconst mjuiDef defSimulation[] =\r\n{\r\n    {mjITEM_SECTION,   \"Simulation\",    1, NULL,                    \"AS\"},\r\n    {mjITEM_RADIO,     \"\",              2, &settings.run,           \"Pause\\nRun\"},\r\n    {mjITEM_BUTTON,    \"Reset\",         2, NULL,                    \" #259\"},\r\n    {mjITEM_BUTTON,    \"Reload\",        2, NULL,                    \"CL\"},\r\n    {mjITEM_BUTTON,    \"Align\",         2, NULL,                    \"CA\"},\r\n    {mjITEM_BUTTON,    \"Copy pose\",     2, NULL,                    \"CC\"},\r\n    {mjITEM_SLIDERINT, \"Key\",           3, &settings.key,           \"0 0\"},\r\n    {mjITEM_BUTTON,    \"Reset to key\",  3},\r\n    {mjITEM_BUTTON,    \"Set key\",       3},\r\n    {mjITEM_END}\r\n};\r\n\r\n\r\n// watch section of UI\r\nconst mjuiDef defWatch[] =\r\n{\r\n    {mjITEM_SECTION,   \"Watch\",         0, NULL,                    \"AW\"},\r\n    {mjITEM_EDITTXT,   \"Field\",         2, settings.field,          \"qpos\"},\r\n    {mjITEM_EDITINT,   \"Index\",         2, &settings.index,         \"1\"},\r\n    {mjITEM_STATIC,    \"Value\",         2, NULL,                    \" \"},\r\n    {mjITEM_END}\r\n};\r\n\r\n\r\n// help strings\r\nconst char help_content[] =\r\n\"Alt mouse button\\n\"\r\n\"UI right hold\\n\"\r\n\"UI title double-click\\n\"\r\n\"Space\\n\"\r\n\"Esc\\n\"\r\n\"Right arrow\\n\"\r\n\"Left arrow\\n\"\r\n\"Down arrow\\n\"\r\n\"Up arrow\\n\"\r\n\"Page Up\\n\"\r\n\"Double-click\\n\"\r\n\"Right double-click\\n\"\r\n\"Ctrl Right double-click\\n\"\r\n\"Scroll, middle drag\\n\"\r\n\"Left drag\\n\"\r\n\"[Shift] right drag\\n\"\r\n\"Ctrl [Shift] drag\\n\"\r\n\"Ctrl [Shift] right drag\";\r\n\r\nconst char help_title[] =\r\n\"Swap left-right\\n\"\r\n\"Show UI shortcuts\\n\"\r\n\"Expand/collapse all  \\n\"\r\n\"Pause\\n\"\r\n\"Free camera\\n\"\r\n\"Step forward\\n\"\r\n\"Step back\\n\"\r\n\"Step forward 100\\n\"\r\n\"Step back 100\\n\"\r\n\"Select parent\\n\"\r\n\"Select\\n\"\r\n\"Center\\n\"\r\n\"Track camera\\n\"\r\n\"Zoom\\n\"\r\n\"View rotate\\n\"\r\n\"View translate\\n\"\r\n\"Object rotate\\n\"\r\n\"Object translate\";\r\n\r\n\r\n// info strings\r\nchar info_title[1000];\r\nchar info_content[1000];\r\n\r\n//----------------------- profiler, sensor, info, watch ---------------------------------\r\n\r\n// init profiler figures\r\nvoid profilerinit(void)\r\n{\r\n    int i, n;\r\n\r\n    // set figures to default\r\n    mjv_defaultFigure(&figconstraint);\r\n    mjv_defaultFigure(&figcost);\r\n    mjv_defaultFigure(&figtimer);\r\n    mjv_defaultFigure(&figsize);\r\n\r\n    // titles\r\n    strcpy(figconstraint.title, \"Counts\");\r\n    strcpy(figcost.title, \"Convergence (log 10)\");\r\n    strcpy(figsize.title, \"Dimensions\");\r\n    strcpy(figtimer.title, \"CPU time (msec)\");\r\n\r\n    // x-labels\r\n    strcpy(figconstraint.xlabel, \"Solver iteration\");\r\n    strcpy(figcost.xlabel, \"Solver iteration\");\r\n    strcpy(figsize.xlabel, \"Video frame\");\r\n    strcpy(figtimer.xlabel, \"Video frame\");\r\n\r\n    // y-tick nubmer formats\r\n    strcpy(figconstraint.yformat, \"%.0f\");\r\n    strcpy(figcost.yformat, \"%.1f\");\r\n    strcpy(figsize.yformat, \"%.0f\");\r\n    strcpy(figtimer.yformat, \"%.2f\");\r\n\r\n    // colors\r\n    figconstraint.figurergba[0] =   0.1f;\r\n    figcost.figurergba[2] =         0.2f;\r\n    figsize.figurergba[0] =         0.1f;\r\n    figtimer.figurergba[2] =        0.2f;\r\n    figconstraint.figurergba[3] =   0.5f;\r\n    figcost.figurergba[3] =         0.5f;\r\n    figsize.figurergba[3] =         0.5f;\r\n    figtimer.figurergba[3] =        0.5f;\r\n\r\n    // legends\r\n    strcpy(figconstraint.linename[0], \"total\");\r\n    strcpy(figconstraint.linename[1], \"active\");\r\n    strcpy(figconstraint.linename[2], \"changed\");\r\n    strcpy(figconstraint.linename[3], \"evals\");\r\n    strcpy(figconstraint.linename[4], \"updates\");\r\n    strcpy(figcost.linename[0], \"improvement\");\r\n    strcpy(figcost.linename[1], \"gradient\");\r\n    strcpy(figcost.linename[2], \"lineslope\");\r\n    strcpy(figsize.linename[0], \"dof\");\r\n    strcpy(figsize.linename[1], \"body\");\r\n    strcpy(figsize.linename[2], \"constraint\");\r\n    strcpy(figsize.linename[3], \"sqrt(nnz)\");\r\n    strcpy(figsize.linename[4], \"contact\");\r\n    strcpy(figsize.linename[5], \"iteration\");\r\n    strcpy(figtimer.linename[0], \"total\");\r\n    strcpy(figtimer.linename[1], \"collision\");\r\n    strcpy(figtimer.linename[2], \"prepare\");\r\n    strcpy(figtimer.linename[3], \"solve\");\r\n    strcpy(figtimer.linename[4], \"other\");\r\n\r\n    // grid sizes\r\n    figconstraint.gridsize[0] = 5;\r\n    figconstraint.gridsize[1] = 5;\r\n    figcost.gridsize[0] = 5;\r\n    figcost.gridsize[1] = 5;\r\n    figsize.gridsize[0] = 3;\r\n    figsize.gridsize[1] = 5;\r\n    figtimer.gridsize[0] = 3;\r\n    figtimer.gridsize[1] = 5;\r\n\r\n    // minimum ranges\r\n    figconstraint.range[0][0] = 0;\r\n    figconstraint.range[0][1] = 20;\r\n    figconstraint.range[1][0] = 0;\r\n    figconstraint.range[1][1] = 80;\r\n    figcost.range[0][0] = 0;\r\n    figcost.range[0][1] = 20;\r\n    figcost.range[1][0] = -15;\r\n    figcost.range[1][1] = 5;\r\n    figsize.range[0][0] = -200;\r\n    figsize.range[0][1] = 0;\r\n    figsize.range[1][0] = 0;\r\n    figsize.range[1][1] = 100;\r\n    figtimer.range[0][0] = -200;\r\n    figtimer.range[0][1] = 0;\r\n    figtimer.range[1][0] = 0;\r\n    figtimer.range[1][1] = 0.4f;\r\n\r\n    // init x axis on history figures (do not show yet)\r\n    for( n=0; n<6; n++ )\r\n        for( i=0; i<mjMAXLINEPNT; i++ )\r\n        {\r\n            figtimer.linedata[n][2*i] = (float)-i;\r\n            figsize.linedata[n][2*i] = (float)-i;\r\n        }\r\n}\r\n\r\n\r\n\r\n// update profiler figures\r\nvoid profilerupdate(void)\r\n{\r\n    int i, n;\r\n\r\n    // update constraint figure\r\n    figconstraint.linepnt[0] = mjMIN(mjMIN(d->solver_iter, mjNSOLVER), mjMAXLINEPNT);\r\n    for( i=1; i<5; i++ )\r\n        figconstraint.linepnt[i] = figconstraint.linepnt[0];\r\n    if( m->opt.solver==mjSOL_PGS )\r\n    {\r\n        figconstraint.linepnt[3] = 0;\r\n        figconstraint.linepnt[4] = 0;\r\n    }\r\n    if( m->opt.solver==mjSOL_CG )\r\n        figconstraint.linepnt[4] = 0;\r\n    for( i=0; i<figconstraint.linepnt[0]; i++ )\r\n    {\r\n        // x\r\n        figconstraint.linedata[0][2*i] = (float)i;\r\n        figconstraint.linedata[1][2*i] = (float)i;\r\n        figconstraint.linedata[2][2*i] = (float)i;\r\n        figconstraint.linedata[3][2*i] = (float)i;\r\n        figconstraint.linedata[4][2*i] = (float)i;\r\n\r\n        // y\r\n        figconstraint.linedata[0][2*i+1] = (float)d->nefc;\r\n        figconstraint.linedata[1][2*i+1] = (float)d->solver[i].nactive;\r\n        figconstraint.linedata[2][2*i+1] = (float)d->solver[i].nchange;\r\n        figconstraint.linedata[3][2*i+1] = (float)d->solver[i].neval;\r\n        figconstraint.linedata[4][2*i+1] = (float)d->solver[i].nupdate;\r\n    }\r\n\r\n    // update cost figure\r\n    figcost.linepnt[0] = mjMIN(mjMIN(d->solver_iter, mjNSOLVER), mjMAXLINEPNT);\r\n    for( i=1; i<3; i++ )\r\n        figcost.linepnt[i] = figcost.linepnt[0];\r\n    if( m->opt.solver==mjSOL_PGS )\r\n    {\r\n        figcost.linepnt[1] = 0;\r\n        figcost.linepnt[2] = 0;\r\n    }\r\n\r\n    for( i=0; i<figcost.linepnt[0]; i++ )\r\n    {\r\n        // x\r\n        figcost.linedata[0][2*i] = (float)i;\r\n        figcost.linedata[1][2*i] = (float)i;\r\n        figcost.linedata[2][2*i] = (float)i;\r\n\r\n        // y\r\n        figcost.linedata[0][2*i+1] = (float)mju_log10(mju_max(mjMINVAL, d->solver[i].improvement));\r\n        figcost.linedata[1][2*i+1] = (float)mju_log10(mju_max(mjMINVAL, d->solver[i].gradient));\r\n        figcost.linedata[2][2*i+1] = (float)mju_log10(mju_max(mjMINVAL, d->solver[i].lineslope));\r\n    }\r\n\r\n    // get timers: total, collision, prepare, solve, other\r\n    mjtNum total = d->timer[mjTIMER_STEP].duration;\r\n    int number = d->timer[mjTIMER_STEP].number;\r\n    if( !number )\r\n    {\r\n        total = d->timer[mjTIMER_FORWARD].duration;\r\n        number = d->timer[mjTIMER_FORWARD].number;\r\n    }\r\n    number = mjMAX(1, number);\r\n    float tdata[5] = { \r\n        (float)(total/number),\r\n        (float)(d->timer[mjTIMER_POS_COLLISION].duration/number),\r\n        (float)(d->timer[mjTIMER_POS_MAKE].duration/number) +\r\n            (float)(d->timer[mjTIMER_POS_PROJECT].duration/number),\r\n        (float)(d->timer[mjTIMER_CONSTRAINT].duration/number),\r\n        0\r\n    };\r\n    tdata[4] = tdata[0] - tdata[1] - tdata[2] - tdata[3];\r\n\r\n    // update figtimer\r\n    int pnt = mjMIN(201, figtimer.linepnt[0]+1);\r\n    for( n=0; n<5; n++ )\r\n    {\r\n        // shift data\r\n        for( i=pnt-1; i>0; i-- )\r\n            figtimer.linedata[n][2*i+1] = figtimer.linedata[n][2*i-1];\r\n\r\n        // assign new\r\n        figtimer.linepnt[n] = pnt;\r\n        figtimer.linedata[n][1] = tdata[n];\r\n    }\r\n\r\n    // get sizes: nv, nbody, nefc, sqrt(nnz), ncont, iter\r\n    float sdata[6] = {\r\n        (float)m->nv,\r\n        (float)m->nbody,\r\n        (float)d->nefc,\r\n        (float)mju_sqrt((mjtNum)d->solver_nnz),\r\n        (float)d->ncon,\r\n        (float)d->solver_iter\r\n    };\r\n\r\n    // update figsize\r\n    pnt = mjMIN(201, figsize.linepnt[0]+1);\r\n    for( n=0; n<6; n++ )\r\n    {\r\n        // shift data\r\n        for( i=pnt-1; i>0; i-- )\r\n            figsize.linedata[n][2*i+1] = figsize.linedata[n][2*i-1];\r\n\r\n        // assign new\r\n        figsize.linepnt[n] = pnt;\r\n        figsize.linedata[n][1] = sdata[n];\r\n    }\r\n}\r\n\r\n\r\n\r\n// show profiler figures\r\nvoid profilershow(mjrRect rect)\r\n{\r\n    mjrRect viewport = {\r\n        rect.left + rect.width - rect.width/4, \r\n        rect.bottom, \r\n        rect.width/4, \r\n        rect.height/4\r\n    };\r\n    mjr_figure(viewport, &figtimer, &con);\r\n    viewport.bottom += rect.height/4;\r\n    mjr_figure(viewport, &figsize, &con);\r\n    viewport.bottom += rect.height/4;\r\n    mjr_figure(viewport, &figcost, &con);\r\n    viewport.bottom += rect.height/4;\r\n    mjr_figure(viewport, &figconstraint, &con);\r\n}\r\n\r\n\r\n\r\n// init sensor figure\r\nvoid sensorinit(void)\r\n{\r\n    // set figure to default\r\n    mjv_defaultFigure(&figsensor);\r\n    figsensor.figurergba[3] = 0.5f;\r\n\r\n    // set flags\r\n    figsensor.flg_extend = 1;\r\n    figsensor.flg_barplot = 1;\r\n    figsensor.flg_symmetric = 1;\r\n\r\n    // title\r\n    strcpy(figsensor.title, \"Sensor data\");\r\n\r\n    // y-tick nubmer format\r\n    strcpy(figsensor.yformat, \"%.0f\");\r\n\r\n    // grid size\r\n    figsensor.gridsize[0] = 2;\r\n    figsensor.gridsize[1] = 3;\r\n\r\n    // minimum range\r\n    figsensor.range[0][0] = 0;\r\n    figsensor.range[0][1] = 0;\r\n    figsensor.range[1][0] = -1;\r\n    figsensor.range[1][1] = 1;\r\n}\r\n\r\n\r\n\r\n// update sensor figure\r\nvoid sensorupdate(void)\r\n{\r\n    static const int maxline = 10;\r\n\r\n    // clear linepnt\r\n    for( int i=0; i<maxline; i++ )\r\n        figsensor.linepnt[i] = 0;\r\n\r\n    // start with line 0\r\n    int lineid = 0;\r\n\r\n    // loop over sensors\r\n    for( int n=0; n<m->nsensor; n++ )\r\n    {\r\n        // go to next line if type is different\r\n        if( n>0 && m->sensor_type[n]!=m->sensor_type[n-1] )\r\n            lineid = mjMIN(lineid+1, maxline-1);\r\n\r\n        // get info about this sensor\r\n        mjtNum cutoff = (m->sensor_cutoff[n]>0 ? m->sensor_cutoff[n] : 1);\r\n        int adr = m->sensor_adr[n];\r\n        int dim = m->sensor_dim[n];\r\n\r\n        // data pointer in line\r\n        int p = figsensor.linepnt[lineid];\r\n\r\n        // fill in data for this sensor\r\n        for( int i=0; i<dim; i++ )\r\n        {\r\n            // check size\r\n            if( (p+2*i)>=mjMAXLINEPNT/2 )\r\n                break;\r\n\r\n            // x\r\n            figsensor.linedata[lineid][2*p+4*i] = (float)(adr+i);\r\n            figsensor.linedata[lineid][2*p+4*i+2] = (float)(adr+i);\r\n\r\n            // y\r\n            figsensor.linedata[lineid][2*p+4*i+1] = 0;\r\n            figsensor.linedata[lineid][2*p+4*i+3] = (float)(d->sensordata[adr+i]/cutoff);\r\n        }\r\n\r\n        // update linepnt\r\n        figsensor.linepnt[lineid] = mjMIN(mjMAXLINEPNT-1, \r\n                                          figsensor.linepnt[lineid]+2*dim);\r\n    }\r\n}\r\n\r\n\r\n\r\n// show sensor figure\r\nvoid sensorshow(mjrRect rect)\r\n{\r\n    // constant width with and without profiler\r\n    int width = settings.profiler ? rect.width/3 : rect.width/4;\r\n\r\n    // render figure on the right\r\n    mjrRect viewport = {\r\n        rect.left + rect.width - width, \r\n        rect.bottom, \r\n        width, \r\n        rect.height/3\r\n    };\r\n    mjr_figure(viewport, &figsensor, &con);\r\n}\r\n\r\n\r\n\r\n// prepare info text\r\nvoid infotext(char* title, char* content, double interval)\r\n{\r\n    char tmp[20];\r\n\r\n    // compute solver error\r\n    mjtNum solerr = 0;\r\n    if( d->solver_iter )\r\n    {\r\n        int ind = mjMIN(d->solver_iter-1,mjNSOLVER-1);\r\n        solerr = mju_min(d->solver[ind].improvement, d->solver[ind].gradient);\r\n        if( solerr==0 )\r\n            solerr = mju_max(d->solver[ind].improvement, d->solver[ind].gradient);\r\n    }\r\n    solerr = mju_log10(mju_max(mjMINVAL, solerr));\r\n\r\n    // prepare info text\r\n    strcpy(title, \"Time\\nSize\\nCPU\\nSolver   \\nFPS\\nstack\\nconbuf\\nefcbuf\");\r\n    sprintf(content, \"%-20.3f\\n%d  (%d con)\\n%.3f\\n%.1f  (%d it)\\n%.0f\\n%.3f\\n%.3f\\n%.3f\",\r\n            d->time, \r\n            d->nefc, d->ncon,\r\n            settings.run ? \r\n                d->timer[mjTIMER_STEP].duration / mjMAX(1, d->timer[mjTIMER_STEP].number) :\r\n                d->timer[mjTIMER_FORWARD].duration / mjMAX(1, d->timer[mjTIMER_FORWARD].number),\r\n            solerr, d->solver_iter, \r\n            1/interval,\r\n            d->maxuse_stack/(double)d->nstack,\r\n            d->maxuse_con/(double)m->nconmax,\r\n            d->maxuse_efc/(double)m->njmax);\r\n\r\n    // add Energy if enabled\r\n    if( mjENABLED(mjENBL_ENERGY) )\r\n    {\r\n        sprintf(tmp, \"\\n%.3f\", d->energy[0]+d->energy[1]);\r\n        strcat(content, tmp);\r\n        strcat(title, \"\\nEnergy\");\r\n    }\r\n\r\n    // add FwdInv if enabled\r\n    if( mjENABLED(mjENBL_FWDINV) )\r\n    {\r\n        sprintf(tmp, \"\\n%.1f %.1f\", \r\n            mju_log10(mju_max(mjMINVAL,d->solver_fwdinv[0])),\r\n            mju_log10(mju_max(mjMINVAL,d->solver_fwdinv[1])));\r\n        strcat(content, tmp);\r\n        strcat(title, \"\\nFwdInv\");\r\n    }   \r\n}\r\n\r\n\r\n\r\n// sprintf forwarding, to avoid compiler warning in x-macro\r\nvoid printfield(char* str, void* ptr)\r\n{\r\n    sprintf(str, \"%g\", *(mjtNum*)ptr);\r\n}\r\n\r\n\r\n\r\n// update watch\r\nvoid watch(void)\r\n{\r\n    // clear\r\n    ui0.sect[SECT_WATCH].item[2].multi.nelem = 1;\r\n    strcpy(ui0.sect[SECT_WATCH].item[2].multi.name[0], \"invalid field\");\r\n\r\n    // prepare constants for NC\r\n    int nv = m->nv;\r\n    int njmax = m->njmax;\r\n\r\n    // find specified field in mjData arrays, update value\r\n    #define X(TYPE, NAME, NR, NC)                                           \\\r\n        if( !strcmp(#NAME, settings.field) && !strcmp(#TYPE, \"mjtNum\") )    \\\r\n        {                                                                   \\\r\n            if( settings.index>=0 && settings.index<m->NR*NC )              \\\r\n                printfield(ui0.sect[SECT_WATCH].item[2].multi.name[0],      \\\r\n                           d->NAME + settings.index);                       \\\r\n            else                                                            \\\r\n                strcpy(ui0.sect[SECT_WATCH].item[2].multi.name[0],          \\\r\n                       \"invalid index\");                                    \\\r\n            return;                                                         \\\r\n        }\r\n\r\n        MJDATA_POINTERS\r\n    #undef X\r\n}\r\n\r\n\r\n\r\n//-------------------------------- UI construction --------------------------------------\r\n\r\n// make physics section of UI\r\nvoid makephysics(int oldstate)\r\n{\r\n    int i;\r\n\r\n    mjuiDef defPhysics[] = \r\n    {\r\n        {mjITEM_SECTION,   \"Physics\",       oldstate, NULL,                 \"AP\"},\r\n        {mjITEM_SELECT,    \"Integrator\",    2, &(m->opt.integrator),        \"Euler\\nRK4\"},\r\n        {mjITEM_SELECT,    \"Collision\",     2, &(m->opt.collision),         \"All\\nPair\\nDynamic\"},\r\n        {mjITEM_SELECT,    \"Cone\",          2, &(m->opt.cone),              \"Pyramidal\\nElliptic\"},\r\n        {mjITEM_SELECT,    \"Jacobian\",      2, &(m->opt.jacobian),          \"Dense\\nSparse\\nAuto\"},\r\n        {mjITEM_SELECT,    \"Solver\",        2, &(m->opt.solver),            \"PGS\\nCG\\nNewton\"},\r\n        {mjITEM_SEPARATOR, \"Algorithmic Parameters\", 1},\r\n        {mjITEM_EDITNUM,   \"Timestep\",      2, &(m->opt.timestep),          \"1 0 1\"},\r\n        {mjITEM_EDITINT,   \"Iterations\",    2, &(m->opt.iterations),        \"1 0 1000\"},\r\n        {mjITEM_EDITNUM,   \"Tolerance\",     2, &(m->opt.tolerance),         \"1 0 1\"},\r\n        {mjITEM_EDITINT,   \"Noslip Iter\",   2, &(m->opt.noslip_iterations), \"1 0 1000\"},\r\n        {mjITEM_EDITNUM,   \"Noslip Tol\",    2, &(m->opt.noslip_tolerance),  \"1 0 1\"},\r\n        {mjITEM_EDITINT,   \"MRR Iter\",      2, &(m->opt.mpr_iterations),    \"1 0 1000\"},\r\n        {mjITEM_EDITNUM,   \"MPR Tol\",       2, &(m->opt.mpr_tolerance),     \"1 0 1\"},\r\n        {mjITEM_EDITNUM,   \"API Rate\",      2, &(m->opt.apirate),           \"1 0 1000\"},\r\n        {mjITEM_SEPARATOR, \"Physical Parameters\", 1},\r\n        {mjITEM_EDITNUM,   \"Gravity\",       2, m->opt.gravity,              \"3\"},\r\n        {mjITEM_EDITNUM,   \"Wind\",          2, m->opt.wind,                 \"3\"},\r\n        {mjITEM_EDITNUM,   \"Magnetic\",      2, m->opt.magnetic,             \"3\"},\r\n        {mjITEM_EDITNUM,   \"Density\",       2, &(m->opt.density),           \"1\"},\r\n        {mjITEM_EDITNUM,   \"Viscosity\",     2, &(m->opt.viscosity),         \"1\"},\r\n        {mjITEM_EDITNUM,   \"Imp Ratio\",     2, &(m->opt.impratio),          \"1\"},\r\n        {mjITEM_SEPARATOR, \"Disable Flags\", 1},\r\n        {mjITEM_END}\r\n    };\r\n    mjuiDef defEnableFlags[] = \r\n    {\r\n        {mjITEM_SEPARATOR, \"Enable Flags\", 1},\r\n        {mjITEM_END}\r\n    };\r\n    mjuiDef defOverride[] = \r\n    {\r\n        {mjITEM_SEPARATOR, \"Contact Override\", 1},\r\n        {mjITEM_EDITNUM,   \"Margin\",        2, &(m->opt.o_margin),          \"1\"},\r\n        {mjITEM_EDITNUM,   \"Sol Imp\",       2, &(m->opt.o_solimp),          \"5\"},\r\n        {mjITEM_EDITNUM,   \"Sol Ref\",       2, &(m->opt.o_solref),          \"2\"},\r\n        {mjITEM_END}\r\n    };\r\n\r\n    // add physics\r\n    mjui_add(&ui0, defPhysics);\r\n\r\n    // add flags programmatically\r\n    mjuiDef defFlag[] = \r\n    {\r\n        {mjITEM_CHECKINT,  \"\", 2, NULL, \"\"}, \r\n        {mjITEM_END}\r\n    };\r\n    for( i=0; i<mjNDISABLE; i++ )\r\n    {\r\n        strcpy(defFlag[0].name, mjDISABLESTRING[i]);\r\n        defFlag[0].pdata = settings.disable + i;\r\n        mjui_add(&ui0, defFlag);\r\n    }\r\n    mjui_add(&ui0, defEnableFlags);\r\n    for( i=0; i<mjNENABLE; i++ )\r\n    {\r\n        strcpy(defFlag[0].name, mjENABLESTRING[i]);\r\n        defFlag[0].pdata = settings.enable + i;\r\n        mjui_add(&ui0, defFlag);\r\n    }\r\n\r\n    // add contact override\r\n    mjui_add(&ui0, defOverride);\r\n}\r\n\r\n\r\n\r\n// make rendering section of UI\r\nvoid makerendering(int oldstate)\r\n{\r\n    int i, j;\r\n\r\n    mjuiDef defRendering[] = \r\n    {\r\n        {mjITEM_SECTION,    \"Rendering\",        oldstate, NULL,             \"AR\"},\r\n        {mjITEM_SELECT,     \"Camera\",           2, &(settings.camera),      \"Free\\nTracking\"},\r\n        {mjITEM_SELECT,     \"Label\",            2, &(vopt.label),           \r\n            \"None\\nBody\\nJoint\\nGeom\\nSite\\nCamera\\nLight\\nTendon\\nActuator\\nConstraint\\nSkin\\nSelection\\nSel Pnt\\nForce\"},\r\n        {mjITEM_SELECT,     \"Frame\",            2, &(vopt.frame),           \r\n            \"None\\nBody\\nGeom\\nSite\\nCamera\\nLight\\nWorld\"},\r\n        {mjITEM_SEPARATOR,  \"Model Elements\",   1},\r\n        {mjITEM_END}\r\n    };\r\n    mjuiDef defOpenGL[] = \r\n    {\r\n        {mjITEM_SEPARATOR, \"OpenGL Effects\", 1},\r\n        {mjITEM_END}\r\n    };\r\n\r\n    // add model cameras, up to UI limit\r\n    for( i=0; i<mjMIN(m->ncam, mjMAXUIMULTI-2); i++ )\r\n    {\r\n        // prepare name\r\n        char camname[mjMAXUITEXT] = \"\\n\";\r\n        if( m->names[m->name_camadr[i]] )\r\n            strcat(camname, m->names+m->name_camadr[i]);\r\n        else\r\n            sprintf(camname, \"\\nCamera %d\", i);\r\n\r\n        // check string length\r\n        if( strlen(camname) + strlen(defRendering[1].other)>=mjMAXUITEXT-1 )\r\n            break;\r\n\r\n        // add camera\r\n        strcat(defRendering[1].other, camname);\r\n    }\r\n\r\n    // add rendering standard\r\n    mjui_add(&ui0, defRendering);\r\n\r\n    // add flags programmatically\r\n    mjuiDef defFlag[] = \r\n    {\r\n        {mjITEM_CHECKBYTE,  \"\", 2, NULL, \"\"}, \r\n        {mjITEM_END}\r\n    };\r\n    for( i=0; i<mjNVISFLAG; i++ )\r\n    {\r\n        // set name, remove \"&\"\r\n        strcpy(defFlag[0].name, mjVISSTRING[i][0]);\r\n        for( j=0; j<strlen(mjVISSTRING[i][0]); j++ )\r\n            if( mjVISSTRING[i][0][j]=='&' )\r\n            {\r\n                strcpy(defFlag[0].name+j, mjVISSTRING[i][0]+j+1);\r\n                break;\r\n            }\r\n\r\n        // set shortcut and data\r\n        sprintf(defFlag[0].other, \" %s\", mjVISSTRING[i][2]);\r\n        defFlag[0].pdata = vopt.flags + i;\r\n        mjui_add(&ui0, defFlag);\r\n    }\r\n    mjui_add(&ui0, defOpenGL);\r\n    for( i=0; i<mjNRNDFLAG; i++ )\r\n    {\r\n        strcpy(defFlag[0].name, mjRNDSTRING[i][0]);\r\n        sprintf(defFlag[0].other, \" %s\", mjRNDSTRING[i][2]);\r\n        defFlag[0].pdata = scn.flags + i;\r\n        mjui_add(&ui0, defFlag);\r\n    }\r\n}\r\n\r\n\r\n\r\n// make group section of UI\r\nvoid makegroup(int oldstate)\r\n{\r\n    mjuiDef defGroup[] = \r\n    {\r\n        {mjITEM_SECTION,    \"Group enable\",     oldstate, NULL,             \"AG\"},\r\n        {mjITEM_SEPARATOR,  \"Geom groups\",  1},\r\n        {mjITEM_CHECKBYTE,  \"Geom 0\",           2, vopt.geomgroup,          \" 0\"},\r\n        {mjITEM_CHECKBYTE,  \"Geom 1\",           2, vopt.geomgroup+1,        \" 1\"},\r\n        {mjITEM_CHECKBYTE,  \"Geom 2\",           2, vopt.geomgroup+2,        \" 2\"},\r\n        {mjITEM_CHECKBYTE,  \"Geom 3\",           2, vopt.geomgroup+3,        \" 3\"},\r\n        {mjITEM_CHECKBYTE,  \"Geom 4\",           2, vopt.geomgroup+4,        \" 4\"},\r\n        {mjITEM_CHECKBYTE,  \"Geom 5\",           2, vopt.geomgroup+5,        \" 5\"},\r\n        {mjITEM_SEPARATOR,  \"Site groups\",  1},\r\n        {mjITEM_CHECKBYTE,  \"Site 0\",           2, vopt.sitegroup,          \"S0\"},\r\n        {mjITEM_CHECKBYTE,  \"Site 1\",           2, vopt.sitegroup+1,        \"S1\"},\r\n        {mjITEM_CHECKBYTE,  \"Site 2\",           2, vopt.sitegroup+2,        \"S2\"},\r\n        {mjITEM_CHECKBYTE,  \"Site 3\",           2, vopt.sitegroup+3,        \"S3\"},\r\n        {mjITEM_CHECKBYTE,  \"Site 4\",           2, vopt.sitegroup+4,        \"S4\"},\r\n        {mjITEM_CHECKBYTE,  \"Site 5\",           2, vopt.sitegroup+5,        \"S5\"},\r\n        {mjITEM_SEPARATOR,  \"Joint groups\", 1},\r\n        {mjITEM_CHECKBYTE,  \"Joint 0\",          2, vopt.jointgroup,         \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Joint 1\",          2, vopt.jointgroup+1,       \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Joint 2\",          2, vopt.jointgroup+2,       \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Joint 3\",          2, vopt.jointgroup+3,       \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Joint 4\",          2, vopt.jointgroup+4,       \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Joint 5\",          2, vopt.jointgroup+5,       \"\"},\r\n        {mjITEM_SEPARATOR,  \"Tendon groups\",    1},\r\n        {mjITEM_CHECKBYTE,  \"Tendon 0\",         2, vopt.tendongroup,        \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Tendon 1\",         2, vopt.tendongroup+1,      \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Tendon 2\",         2, vopt.tendongroup+2,      \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Tendon 3\",         2, vopt.tendongroup+3,      \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Tendon 4\",         2, vopt.tendongroup+4,      \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Tendon 5\",         2, vopt.tendongroup+5,      \"\"},\r\n        {mjITEM_SEPARATOR,  \"Actuator groups\", 1},\r\n        {mjITEM_CHECKBYTE,  \"Actuator 0\",       2, vopt.actuatorgroup,      \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Actuator 1\",       2, vopt.actuatorgroup+1,    \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Actuator 2\",       2, vopt.actuatorgroup+2,    \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Actuator 3\",       2, vopt.actuatorgroup+3,    \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Actuator 4\",       2, vopt.actuatorgroup+4,    \"\"},\r\n        {mjITEM_CHECKBYTE,  \"Actuator 5\",       2, vopt.actuatorgroup+5,    \"\"},\r\n        {mjITEM_END}\r\n    };\r\n\r\n    // add section\r\n    mjui_add(&ui0, defGroup);\r\n}\r\n\r\n\r\n\r\n// make joint section of UI\r\nvoid makejoint(int oldstate)\r\n{\r\n    int i;\r\n\r\n    mjuiDef defJoint[] = \r\n    {\r\n        {mjITEM_SECTION, \"Joint\", oldstate, NULL, \"AJ\"},\r\n        {mjITEM_END}\r\n    };\r\n    mjuiDef defSlider[] = \r\n    {\r\n        {mjITEM_SLIDERNUM, \"\", 2, NULL, \"0 1\"},\r\n        {mjITEM_END}\r\n    };\r\n\r\n    // add section\r\n    mjui_add(&ui1, defJoint);\r\n    defSlider[0].state = 4;\r\n\r\n    // add scalar joints, exit if UI limit reached\r\n    int itemcnt = 0;\r\n    for( i=0; i<m->njnt && itemcnt<mjMAXUIITEM; i++ )\r\n        if( (m->jnt_type[i]==mjJNT_HINGE || m->jnt_type[i]==mjJNT_SLIDE) )\r\n        {\r\n            // skip if joint group is disabled\r\n            if( !vopt.jointgroup[mjMAX(0, mjMIN(mjNGROUP-1, m->jnt_group[i]))] )\r\n                continue;\r\n\r\n            // set data and name\r\n            defSlider[0].pdata = d->qpos + m->jnt_qposadr[i];\r\n            if( m->names[m->name_jntadr[i]] )\r\n                mju_strncpy(defSlider[0].name, m->names+m->name_jntadr[i], \r\n                            mjMAXUINAME);\r\n            else\r\n                sprintf(defSlider[0].name, \"joint %d\", i);\r\n\r\n            // set range\r\n            if( m->jnt_limited[i] )\r\n                sprintf(defSlider[0].other, \"%.4g %.4g\", \r\n                    m->jnt_range[2*i], m->jnt_range[2*i+1]);\r\n            else if( m->jnt_type[i]==mjJNT_SLIDE )\r\n                strcpy(defSlider[0].other, \"-1 1\");\r\n            else\r\n                strcpy(defSlider[0].other, \"-3.1416 3.1416\");\r\n\r\n            // add and count\r\n            mjui_add(&ui1, defSlider);\r\n            itemcnt++;\r\n        }\r\n}\r\n\r\n\r\n\r\n// make control section of UI\r\nvoid makecontrol(int oldstate)\r\n{\r\n    int i;\r\n\r\n    mjuiDef defControl[] = \r\n    {\r\n        {mjITEM_SECTION, \"Control\", oldstate, NULL, \"AC\"},\r\n        {mjITEM_BUTTON,  \"Clear all\", 2},\r\n        {mjITEM_END}\r\n    };\r\n    mjuiDef defSlider[] = \r\n    {\r\n        {mjITEM_SLIDERNUM, \"\", 2, NULL, \"0 1\"},\r\n        {mjITEM_END}\r\n    };\r\n\r\n    // add section\r\n    mjui_add(&ui1, defControl);\r\n    defSlider[0].state = 2;\r\n\r\n    // add controls, exit if UI limit reached (Clear button already added)\r\n    int itemcnt = 1;\r\n    for( i=0; i<m->nu && itemcnt<mjMAXUIITEM; i++ )\r\n    {\r\n        // skip if actuator group is disabled\r\n        if( !vopt.actuatorgroup[mjMAX(0, mjMIN(mjNGROUP-1, m->actuator_group[i]))] )\r\n            continue;\r\n\r\n        // set data and name\r\n        defSlider[0].pdata = d->ctrl + i;\r\n        if( m->names[m->name_actuatoradr[i]] )\r\n            mju_strncpy(defSlider[0].name, m->names+m->name_actuatoradr[i], \r\n                        mjMAXUINAME);\r\n        else\r\n            sprintf(defSlider[0].name, \"control %d\", i);\r\n\r\n        // set range\r\n        if( m->actuator_ctrllimited[i] )\r\n            sprintf(defSlider[0].other, \"%.4g %.4g\", \r\n                m->actuator_ctrlrange[2*i], m->actuator_ctrlrange[2*i+1]);\r\n        else\r\n            strcpy(defSlider[0].other, \"-1 1\");\r\n\r\n        // add and count\r\n        mjui_add(&ui1, defSlider);\r\n        itemcnt++;\r\n    }\r\n}\r\n\r\n\r\n\r\n// make model-dependent UI sections\r\nvoid makesections(void)\r\n{\r\n    int i;\r\n\r\n    // get section open-close state, UI 0\r\n    int oldstate0[NSECT0];\r\n    for( i=0; i<NSECT0; i++ )\r\n    {\r\n        oldstate0[i] = 0;\r\n        if( ui0.nsect>i )\r\n            oldstate0[i] = ui0.sect[i].state;\r\n    }\r\n\r\n    // get section open-close state, UI 1\r\n    int oldstate1[NSECT1];\r\n    for( i=0; i<NSECT1; i++ )\r\n    {\r\n        oldstate1[i] = 0;\r\n        if( ui1.nsect>i )\r\n            oldstate1[i] = ui1.sect[i].state;\r\n    }\r\n\r\n    // clear model-dependent sections of UI\r\n    ui0.nsect = SECT_PHYSICS;\r\n    ui1.nsect = 0;\r\n\r\n    // make\r\n    makephysics(oldstate0[SECT_PHYSICS]);\r\n    makerendering(oldstate0[SECT_RENDERING]);\r\n    makegroup(oldstate0[SECT_GROUP]);\r\n    makejoint(oldstate1[SECT_JOINT]);\r\n    makecontrol(oldstate1[SECT_CONTROL]);\r\n}\r\n\r\n\r\n\r\n//-------------------------------- utility functions ------------------------------------\r\n\r\n// align and scale view\r\nvoid alignscale(void)\r\n{\r\n    // autoscale\r\n    cam.lookat[0] = m->stat.center[0];\r\n    cam.lookat[1] = m->stat.center[1];\r\n    cam.lookat[2] = m->stat.center[2];\r\n    cam.distance = 1.5 * m->stat.extent;\r\n\r\n    // set to free camera\r\n    cam.type = mjCAMERA_FREE;\r\n}\r\n\r\n\r\n\r\n// copy qpos to clipboard as key\r\nvoid copykey(void)\r\n{\r\n    char clipboard[5000] = \"<key qpos='\";\r\n    char buf[200];\r\n\r\n    // prepare string\r\n    for( int i=0; i<m->nq; i++ )\r\n    {\r\n        sprintf(buf, i==m->nq-1 ? \"%g\" : \"%g \", d->qpos[i]);\r\n        strcat(clipboard, buf);\r\n    }\r\n    strcat(clipboard, \"'/>\");\r\n\r\n    // copy to clipboard\r\n    glfwSetClipboardString(window, clipboard);\r\n}\r\n\r\n\r\n\r\n// millisecond timer, for MuJoCo built-in profiler\r\nmjtNum timer(void)\r\n{\r\n    return (mjtNum)(1000*glfwGetTime());\r\n}\r\n\r\n\r\n\r\n// clear all times\r\nvoid cleartimers(void)\r\n{\r\n    for( int i=0; i<mjNTIMER; i++ )\r\n    {\r\n        d->timer[i].duration = 0;\r\n        d->timer[i].number = 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n// update UI 0 when MuJoCo structures change (except for joint sliders)\r\nvoid updatesettings(void)\r\n{\r\n    int i;\r\n\r\n    // physics flags\r\n    for( i=0; i<mjNDISABLE; i++ )\r\n        settings.disable[i] = ((m->opt.disableflags & (1<<i)) !=0 );\r\n    for( i=0; i<mjNENABLE; i++ )\r\n        settings.enable[i] = ((m->opt.enableflags & (1<<i)) !=0 );\r\n\r\n    // camera\r\n    if( cam.type==mjCAMERA_FIXED )\r\n        settings.camera = 2 + cam.fixedcamid;\r\n    else if( cam.type==mjCAMERA_TRACKING )\r\n        settings.camera = 1;\r\n    else \r\n        settings.camera = 0;\r\n\r\n    // update UI\r\n    mjui_update(-1, -1, &ui0, &uistate, &con);\r\n}\r\n\r\n\r\n\r\n// drop file callback\r\nvoid drop(GLFWwindow* window, int count, const char** paths)\r\n{\r\n    // make sure list is non-empty\r\n    if( count>0 )\r\n    {\r\n        mju_strncpy(filename, paths[0], 1000);\r\n        settings.loadrequest = 1;\r\n    }\r\n}\r\n\r\n\r\n\r\n// load mjb or xml model\r\nvoid loadmodel(void)\r\n{\r\n    // clear request\r\n    settings.loadrequest = 0;\r\n\r\n    // make sure filename is not empty\r\n    if( !filename[0]  )\r\n        return;\r\n\r\n    // load and compile\r\n    char error[500] = \"\";\r\n    mjModel* mnew = 0;                 \r\n    if( strlen(filename)>4 && !strcmp(filename+strlen(filename)-4, \".mjb\") )\r\n    {        \r\n        mnew = mj_loadModel(filename, NULL);        \r\n        if( !mnew )\r\n            strcpy(error, \"could not load binary model\");\r\n    }\r\n    ///////////////////reload///////////////////////////////////////\r\n    else        \r\n    {\r\n        mnew = mj_loadXML(filename, NULL, error, 500);\r\n    }\r\n    ///////////////////reload///////////////////////////////////////\r\n    if( !mnew )\r\n    {\r\n        printf(\"%s\\n\", error);\r\n        return;\r\n    }\r\n\r\n    // compiler warning: print and pause\r\n    if( error[0] )\r\n    {\r\n        // mj_forward() below will print the warning message\r\n        printf(\"Model compiled, but simulation warning (paused):\\n  %s\\n\\n\",\r\n                error);\r\n        settings.run = 0;\r\n    }\r\n\r\n    // delete old model, assign new\r\n    mj_deleteData(d);\r\n    mj_deleteModel(m);\r\n    m = mnew;\r\n    d = mj_makeData(m);\r\n    mj_forward(m, d);\r\n\r\n    // re-create scene and context\r\n    mjv_makeScene(m, &scn, maxgeom);\r\n    mjr_makeContext(m, &con, 50*(settings.font+1));\r\n\r\n    // clear perturbation state\r\n    pert.active = 0;\r\n    pert.select = 0;\r\n    pert.skinselect = -1;\r\n\r\n    // align and scale view, update scene\r\n    alignscale();\r\n    mjv_updateScene(m, d, &vopt, &pert, &cam, mjCAT_ALL, &scn);\r\n\r\n    // set window title to model name\r\n    if( window && m->names )\r\n    {\r\n        char title[200] = \"Simulate : \";\r\n        strcat(title, m->names);\r\n        glfwSetWindowTitle(window, title);\r\n    }\r\n\r\n    // set keyframe range and divisions\r\n    ui0.sect[SECT_SIMULATION].item[6].slider.range[0] = 0;\r\n    ui0.sect[SECT_SIMULATION].item[6].slider.range[1] = mjMAX(0, m->nkey - 1);\r\n    ui0.sect[SECT_SIMULATION].item[6].slider.divisions = mjMAX(1, m->nkey - 1);\r\n\r\n    // rebuild UI sections\r\n    makesections();\r\n\r\n    // full ui update\r\n    uiModify(window, &ui0, &uistate, &con);\r\n    uiModify(window, &ui1, &uistate, &con);\r\n    updatesettings();\r\n}\r\n\r\n\r\n\r\n//--------------------------------- UI hooks (for uitools.c) ----------------------------\r\n\r\n// determine enable/disable item state given category\r\nint uiPredicate(int category, void* userdata)\r\n{\r\n    switch( category )\r\n    {\r\n    case 2:                 // require model\r\n        return (m!=NULL);\r\n\r\n    case 3:                 // require model and nkey\r\n        return (m && m->nkey);\r\n\r\n    case 4:                 // require model and paused\r\n        return (m && !settings.run);\r\n\r\n    default:\r\n        return 1;\r\n    }\r\n}\r\n\r\n\r\n\r\n// set window layout\r\nvoid uiLayout(mjuiState* state)\r\n{\r\n    mjrRect* rect = state->rect;\r\n\r\n    // set number of rectangles\r\n    state->nrect = 4;\r\n\r\n    // rect 0: entire framebuffer\r\n    rect[0].left = 0;\r\n    rect[0].bottom = 0;\r\n    glfwGetFramebufferSize(window, &rect[0].width, &rect[0].height);\r\n\r\n    // rect 1: UI 0\r\n    rect[1].left = 0;\r\n    rect[1].width = settings.ui0 ? ui0.width : 0;\r\n    rect[1].bottom = 0;\r\n    rect[1].height = rect[0].height;\r\n\r\n    // rect 2: UI 1\r\n    rect[2].width = settings.ui1 ? ui1.width : 0;\r\n    rect[2].left = mjMAX(0, rect[0].width - rect[2].width);\r\n    rect[2].bottom = 0;\r\n    rect[2].height = rect[0].height;\r\n\r\n    // rect 3: 3D plot (everything else is an overlay)\r\n    rect[3].left = rect[1].width;\r\n    rect[3].width = mjMAX(0, rect[0].width - rect[1].width - rect[2].width);\r\n    rect[3].bottom = 0;\r\n    rect[3].height = rect[0].height;\r\n}\r\n\r\n\r\n\r\n// handle UI event\r\nvoid uiEvent(mjuiState* state)\r\n{\r\n    int i;\r\n    char err[200];\r\n\r\n    // call UI 0 if event is directed to it\r\n    if( (state->dragrect==ui0.rectid) ||\r\n        (state->dragrect==0 && state->mouserect==ui0.rectid) ||\r\n        state->type==mjEVENT_KEY )\r\n    {\r\n        // process UI event\r\n        mjuiItem* it = mjui_event(&ui0, state, &con);\r\n\r\n        // file section\r\n        if( it && it->sectionid==SECT_FILE )\r\n        {\r\n            switch( it->itemid )\r\n            {\r\n            case 0:             // Save xml\r\n                if( !mj_saveLastXML(\"mjmodel.xml\", m, err, 200) )\r\n                    printf(\"Save XML error: %s\", err);\r\n                break;\r\n\r\n            case 1:             // Save mjb\r\n                mj_saveModel(m, \"mjmodel.mjb\", NULL, 0);\r\n                break;\r\n\r\n            case 2:             // Print model\r\n                mj_printModel(m, \"MJMODEL.TXT\");\r\n                break;\r\n\r\n            case 3:             // Print data\r\n                mj_printData(m, d, \"MJDATA.TXT\");\r\n                break;\r\n\r\n            case 4:             // Quit\r\n                settings.exitrequest = 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // option section\r\n        else if( it && it->sectionid==SECT_OPTION )\r\n        {\r\n            switch( it->itemid )\r\n            {\r\n            case 0:             // Spacing\r\n                ui0.spacing = mjui_themeSpacing(settings.spacing);\r\n                ui1.spacing = mjui_themeSpacing(settings.spacing);\r\n                break;\r\n\r\n            case 1:             // Color\r\n                ui0.color = mjui_themeColor(settings.color);\r\n                ui1.color = mjui_themeColor(settings.color);\r\n                break;\r\n\r\n            case 2:             // Font\r\n                mjr_changeFont(50*(settings.font+1), &con);\r\n                break;\r\n\r\n            case 9:             // Full screen\r\n                if( glfwGetWindowMonitor(window) )\r\n                {\r\n                    // restore window from saved data\r\n                    glfwSetWindowMonitor(window, NULL, windowpos[0], windowpos[1], \r\n                                         windowsize[0], windowsize[1], 0);\r\n                }\r\n\r\n                // currently windowed: switch to full screen\r\n                else\r\n                {\r\n                    // save window data\r\n                    glfwGetWindowPos(window, windowpos, windowpos+1);\r\n                    glfwGetWindowSize(window, windowsize, windowsize+1);\r\n\r\n                    // switch\r\n                    glfwSetWindowMonitor(window, glfwGetPrimaryMonitor(), 0, 0, \r\n                                         vmode.width, vmode.height, vmode.refreshRate);\r\n                }\r\n\r\n                // reinstante vsync, just in case\r\n                glfwSwapInterval(settings.vsync);\r\n                break;\r\n\r\n            case 10:            // Vertical sync\r\n                glfwSwapInterval(settings.vsync);\r\n                break;\r\n            }\r\n\r\n            // modify UI\r\n            uiModify(window, &ui0, state, &con);\r\n            uiModify(window, &ui1, state, &con);\r\n        }\r\n\r\n        // simulation section\r\n        else if( it && it->sectionid==SECT_SIMULATION )\r\n        {\r\n            switch( it->itemid )\r\n            {\r\n            case 1:             // Reset\r\n                if( m )\r\n                {\r\n                    mj_resetData(m, d);\r\n                    mj_forward(m, d);\r\n                    profilerupdate();\r\n                    sensorupdate();\r\n                    updatesettings();\r\n                }\r\n                break;\r\n\r\n            case 2:             // Reload\r\n                settings.loadrequest = 1;\r\n                break;\r\n\r\n            case 3:             // Align\r\n                alignscale();\r\n                updatesettings();\r\n                break;\r\n\r\n            case 4:             // Copy pose\r\n                copykey();\r\n                break;\r\n\r\n            case 5:             // Adjust key\r\n            case 6:             // Reset to key\r\n                i = settings.key;\r\n                d->time = m->key_time[i];\r\n                mju_copy(d->qpos, m->key_qpos+i*m->nq, m->nq);\r\n                mju_copy(d->qvel, m->key_qvel+i*m->nv, m->nv);\r\n                mju_copy(d->act, m->key_act+i*m->na, m->na);\r\n                mj_forward(m, d);\r\n                profilerupdate();\r\n                sensorupdate();\r\n                updatesettings();\r\n                break;\r\n\r\n            case 7:             // Set key\r\n                i = settings.key;\r\n                m->key_time[i] = d->time;\r\n                mju_copy(m->key_qpos+i*m->nq, d->qpos, m->nq);\r\n                mju_copy(m->key_qvel+i*m->nv, d->qvel, m->nv);\r\n                mju_copy(m->key_act+i*m->na, d->act, m->na);\r\n                break;\r\n            }\r\n        }\r\n\r\n        // physics section\r\n        else if( it && it->sectionid==SECT_PHYSICS )\r\n        {\r\n            // update disable flags in mjOption\r\n            m->opt.disableflags = 0;\r\n            for( i=0; i<mjNDISABLE; i++ )\r\n                if( settings.disable[i] )\r\n                    m->opt.disableflags |= (1<<i);\r\n\r\n            // update enable flags in mjOption\r\n            m->opt.enableflags = 0;\r\n            for( i=0; i<mjNENABLE; i++ )\r\n                if( settings.enable[i] )\r\n                    m->opt.enableflags |= (1<<i);\r\n        }\r\n\r\n        // rendering section\r\n        else if( it && it->sectionid==SECT_RENDERING )\r\n        {\r\n            // set camera in mjvCamera\r\n            if( settings.camera==0 )\r\n                cam.type = mjCAMERA_FREE;\r\n            else if( settings.camera==1 )\r\n            {\r\n                if( pert.select>0 )\r\n                {\r\n                    cam.type = mjCAMERA_TRACKING;\r\n                    cam.trackbodyid = pert.select;\r\n                    cam.fixedcamid = -1;\r\n                }\r\n                else\r\n                {\r\n                    cam.type = mjCAMERA_FREE;\r\n                    settings.camera = 0;\r\n                    mjui_update(SECT_RENDERING, -1, &ui0, &uistate, &con);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                cam.type = mjCAMERA_FIXED;\r\n                cam.fixedcamid = settings.camera - 2;\r\n            }\r\n        }\r\n\r\n        // group section\r\n        else if( it && it->sectionid==SECT_GROUP )\r\n        {\r\n            // remake joint section if joint group changed\r\n            if( it->name[0]=='J' && it->name[1]=='o' )\r\n            {\r\n                ui1.nsect = SECT_JOINT;\r\n                makejoint(ui1.sect[SECT_JOINT].state);\r\n                ui1.nsect = NSECT1;\r\n                uiModify(window, &ui1, state, &con);\r\n            }\r\n\r\n            // remake control section if actuator group changed\r\n            if( it->name[0]=='A' && it->name[1]=='c' )\r\n            {\r\n                ui1.nsect = SECT_CONTROL;\r\n                makecontrol(ui1.sect[SECT_CONTROL].state);\r\n                ui1.nsect = NSECT1;\r\n                uiModify(window, &ui1, state, &con);\r\n            }\r\n        }\r\n\r\n        // stop if UI processed event\r\n        if( it!=NULL || (state->type==mjEVENT_KEY && state->key==0) )\r\n            return;\r\n    }\r\n\r\n    // call UI 1 if event is directed to it\r\n    if( (state->dragrect==ui1.rectid) ||\r\n        (state->dragrect==0 && state->mouserect==ui1.rectid) ||\r\n        state->type==mjEVENT_KEY )\r\n    {\r\n        // process UI event\r\n        mjuiItem* it = mjui_event(&ui1, state, &con);\r\n\r\n        // control section\r\n        if( it && it->sectionid==SECT_CONTROL )\r\n        {\r\n            // clear controls\r\n            if( it->itemid==0 )\r\n            {\r\n                mju_zero(d->ctrl, m->nu);\r\n                mjui_update(SECT_CONTROL, -1, &ui1, &uistate, &con);\r\n            }\r\n        }\r\n\r\n        // stop if UI processed event\r\n        if( it!=NULL || (state->type==mjEVENT_KEY && state->key==0) )\r\n            return;\r\n    }\r\n\r\n    // shortcut not handled by UI\r\n    if( state->type==mjEVENT_KEY && state->key!=0 )\r\n    {\r\n        switch( state->key )\r\n        {\r\n        case ' ':                   // Mode\r\n            if( m )\r\n            {\r\n                settings.run = 1 - settings.run;\r\n                pert.active = 0;\r\n                mjui_update(-1, -1, &ui0, state, &con);\r\n            }\r\n            break;\r\n\r\n        case mjKEY_RIGHT:           // step forward\r\n            if( m && !settings.run )\r\n            {\r\n                cleartimers();\r\n                mj_step(m, d);\r\n                profilerupdate();\r\n                sensorupdate();\r\n                updatesettings();\r\n            }\r\n            break;\r\n\r\n        case mjKEY_LEFT:            // step back\r\n            if( m && !settings.run )\r\n            {\r\n                m->opt.timestep = -m->opt.timestep;\r\n                cleartimers();\r\n                mj_step(m, d);\r\n                m->opt.timestep = -m->opt.timestep;\r\n                profilerupdate();\r\n                sensorupdate();\r\n                updatesettings();\r\n            }\r\n            break;\r\n\r\n        case mjKEY_DOWN:            // step forward 100\r\n            if( m && !settings.run )\r\n            {\r\n                cleartimers();\r\n                for( i=0; i<100; i++ )\r\n                    mj_step(m, d);\r\n                profilerupdate();\r\n                sensorupdate();\r\n                updatesettings();\r\n            }\r\n            break;\r\n\r\n        case mjKEY_UP:              // step back 100\r\n            if( m && !settings.run )\r\n            {\r\n                m->opt.timestep = -m->opt.timestep;\r\n                cleartimers();\r\n                for( i=0; i<100; i++ )\r\n                    mj_step(m, d);\r\n                m->opt.timestep = -m->opt.timestep;\r\n                profilerupdate();\r\n                sensorupdate();\r\n                updatesettings();\r\n            }\r\n            break;\r\n\r\n        case mjKEY_PAGE_UP:         // select parent body\r\n            if( m && pert.select>0 )\r\n            {\r\n                pert.select = m->body_parentid[pert.select];\r\n                pert.skinselect = -1;\r\n\r\n                // stop perturbation if world reached\r\n                if( pert.select<=0 )\r\n                    pert.active = 0;\r\n            }\r\n\r\n            break;\r\n\r\n        case mjKEY_ESCAPE:          // free camera\r\n            cam.type = mjCAMERA_FREE;\r\n            settings.camera = 0;\r\n            mjui_update(SECT_RENDERING, -1, &ui0, &uistate, &con);\r\n            break;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    // 3D scroll\r\n    if( state->type==mjEVENT_SCROLL && state->mouserect==3 && m )\r\n    {\r\n        // emulate vertical mouse motion = 5% of window height\r\n        mjv_moveCamera(m, mjMOUSE_ZOOM, 0, -0.05*state->sy, &scn, &cam);\r\n\r\n        return;\r\n    }\r\n\r\n    // 3D press\r\n    if( state->type==mjEVENT_PRESS && state->mouserect==3 && m )\r\n    {\r\n        // set perturbation\r\n        int newperturb = 0;\r\n        if( state->control && pert.select>0 )\r\n        {\r\n            // right: translate;  left: rotate\r\n            if( state->right )\r\n                newperturb = mjPERT_TRANSLATE;\r\n            else if( state->left )\r\n                newperturb = mjPERT_ROTATE;\r\n\r\n            // perturbation onset: reset reference\r\n            if( newperturb && !pert.active )\r\n                mjv_initPerturb(m, d, &scn, &pert);\r\n        }\r\n        pert.active = newperturb;\r\n\r\n        // handle double-click\r\n        if( state->doubleclick )\r\n        {\r\n            // determine selection mode\r\n            int selmode;\r\n            if( state->button==mjBUTTON_LEFT )\r\n                selmode = 1;\r\n            else if( state->control )\r\n                selmode = 3;\r\n            else\r\n                selmode = 2;\r\n\r\n            // find geom and 3D click point, get corresponding body\r\n            mjrRect r = state->rect[3];\r\n            mjtNum selpnt[3];\r\n            int selgeom, selskin;\r\n            int selbody = mjv_select(m, d, &vopt,\r\n                                     (mjtNum)r.width/(mjtNum)r.height, \r\n                                     (mjtNum)(state->x-r.left)/(mjtNum)r.width, \r\n                                     (mjtNum)(state->y-r.bottom)/(mjtNum)r.height, \r\n                                     &scn, selpnt, &selgeom, &selskin);\r\n\r\n            // set lookat point, start tracking is requested\r\n            if( selmode==2 || selmode==3 )\r\n            {\r\n                // copy selpnt if anything clicked\r\n                if( selbody>=0 )\r\n                    mju_copy3(cam.lookat, selpnt);\r\n\r\n                // switch to tracking camera if dynamic body clicked\r\n                if( selmode==3 && selbody>0 )\r\n                {\r\n                    // mujoco camera\r\n                    cam.type = mjCAMERA_TRACKING;\r\n                    cam.trackbodyid = selbody;\r\n                    cam.fixedcamid = -1;\r\n\r\n                    // UI camera\r\n                    settings.camera = 1;\r\n                    mjui_update(SECT_RENDERING, -1, &ui0, &uistate, &con);\r\n                }\r\n            }\r\n\r\n            // set body selection\r\n            else\r\n            {\r\n                if( selbody>=0 )\r\n                {\r\n                    // record selection\r\n                    pert.select = selbody;\r\n                    pert.skinselect = selskin;\r\n\r\n                    // compute localpos\r\n                    mjtNum tmp[3];\r\n                    mju_sub3(tmp, selpnt, d->xpos+3*pert.select);\r\n                    mju_mulMatTVec(pert.localpos, d->xmat+9*pert.select, tmp, 3, 3);\r\n                }\r\n                else\r\n                {\r\n                    pert.select = 0;\r\n                    pert.skinselect = -1;\r\n                }\r\n            }\r\n\r\n            // stop perturbation on select\r\n            pert.active = 0;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    // 3D release\r\n    if( state->type==mjEVENT_RELEASE && state->dragrect==3 && m )\r\n    {\r\n        // stop perturbation\r\n        pert.active = 0;\r\n\r\n        return;\r\n    }\r\n\r\n    // 3D move\r\n    if( state->type==mjEVENT_MOVE && state->dragrect==3 && m )\r\n    {\r\n        // determine action based on mouse button\r\n        mjtMouse action;\r\n        if( state->right )\r\n            action = state->shift ? mjMOUSE_MOVE_H : mjMOUSE_MOVE_V;\r\n        else if( state->left )\r\n            action = state->shift ? mjMOUSE_ROTATE_H : mjMOUSE_ROTATE_V;\r\n        else\r\n            action = mjMOUSE_ZOOM;\r\n\r\n        // move perturb or camera\r\n        mjrRect r = state->rect[3];\r\n        if( pert.active )\r\n            mjv_movePerturb(m, d, action, state->dx/r.height, -state->dy/r.height, \r\n                            &scn, &pert);\r\n        else\r\n            mjv_moveCamera(m, action, state->dx/r.height, -state->dy/r.height, \r\n                           &scn, &cam);\r\n\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n\r\n//--------------------------- rendering and simulation ----------------------------------\r\n\r\n// sim thread synchronization\r\nstd::mutex mtx;\r\n\r\n\r\n// prepare to render\r\nvoid prepare(void)\r\n{\r\n    // data for FPS calculation\r\n    static double lastupdatetm = 0;\r\n\r\n    // update interval, save update time\r\n    double tmnow = glfwGetTime();\r\n    double interval = tmnow - lastupdatetm;\r\n    interval = mjMIN(1, mjMAX(0.0001, interval));\r\n    lastupdatetm = tmnow;\r\n\r\n    // no model: nothing to do\r\n    if( !m )\r\n        return;\r\n\r\n    // update scene\r\n    mjv_updateScene(m, d, &vopt, &pert, &cam, mjCAT_ALL, &scn);\r\n\r\n    // update watch \r\n    if( settings.ui0 && ui0.sect[SECT_WATCH].state )\r\n    {\r\n\t\twatch();\r\n\t\tmjui_update(SECT_WATCH, -1, &ui0, &uistate, &con);\r\n    }\r\n\r\n    // ipdate joint\r\n    if( settings.ui1 && ui1.sect[SECT_JOINT].state )\r\n            mjui_update(SECT_JOINT, -1, &ui1, &uistate, &con);\r\n\r\n    // update info text\r\n    if( settings.info )\r\n        infotext(info_title, info_content, interval);\r\n\r\n    // update profiler\r\n    if( settings.profiler && settings.run )\r\n        profilerupdate();\r\n\r\n    // update sensor\r\n    if( settings.sensor && settings.run )\r\n        sensorupdate();\r\n\r\n    // clear timers once profiler info has been copied\r\n    cleartimers();\r\n}\r\n\r\n\r\n\r\n// render im main thread (while simulating in background thread)\r\nvoid render(GLFWwindow* window)\r\n{\r\n    // get 3D rectangle and reduced for profiler\r\n    mjrRect rect = uistate.rect[3];\r\n    mjrRect smallrect = rect;\r\n    if( settings.profiler )\r\n        smallrect.width = rect.width - rect.width/4;\r\n\r\n    // no model\r\n    if( !m )\r\n    {\r\n        // blank screen\r\n        mjr_rectangle(rect, 0.2f, 0.3f, 0.4f, 1);\r\n\r\n        // label\r\n        if( settings.loadrequest )\r\n            mjr_overlay(mjFONT_BIG, mjGRID_TOPRIGHT, smallrect, \r\n                        \"loading\", NULL, &con);\r\n        else\r\n            mjr_overlay(mjFONT_NORMAL, mjGRID_TOPLEFT, rect, \r\n                        \"Drag-and-drop model file here\", 0, &con);\r\n\r\n        // render uis\r\n        if( settings.ui0 )\r\n            mjui_render(&ui0, &uistate, &con);\r\n        if( settings.ui1 )\r\n            mjui_render(&ui1, &uistate, &con);\r\n\r\n        // finalize\r\n        glfwSwapBuffers(window); \r\n\r\n        return;\r\n    }\r\n\r\n    // render scene\r\n    mjr_render(rect, &scn, &con);\r\n\r\n    // show pause/loading label\r\n    if( !settings.run || settings.loadrequest )\r\n        mjr_overlay(mjFONT_BIG, mjGRID_TOPRIGHT, smallrect, \r\n                    settings.loadrequest ? \"loading\" : \"pause\", NULL, &con);\r\n\r\n    // show ui 0\r\n    if( settings.ui0 )\r\n        mjui_render(&ui0, &uistate, &con);\r\n\r\n    // show ui 1\r\n    if( settings.ui1 )\r\n        mjui_render(&ui1, &uistate, &con);\r\n\r\n    // show help\r\n    if( settings.help )\r\n        mjr_overlay(mjFONT_NORMAL, mjGRID_TOPLEFT, rect, help_title, help_content, &con);\r\n\r\n    // show info\r\n    if( settings.info )\r\n        mjr_overlay(mjFONT_NORMAL, mjGRID_BOTTOMLEFT, rect, \r\n                    info_title, info_content, &con);\r\n\r\n    // show profiler\r\n    if( settings.profiler )\r\n        profilershow(rect);\r\n\r\n    // show sensor\r\n    if( settings.sensor )\r\n        sensorshow(smallrect);\r\n\r\n    // finalize\r\n    glfwSwapBuffers(window);\r\n}\r\n\r\n\r\n// simulate in background thread (while rendering in main thread)\r\nvoid simulate(void)\r\n{\r\n    // cpu-sim syncronization point\r\n    double cpusync = 0;\r\n    mjtNum simsync = 0;\r\n    bool initialpos = true;\r\n\r\n    // bool inisdsd = true;\r\n\r\n    // run until asked to exit\r\n    while( !settings.exitrequest )\r\n    {\r\n        // sleep for 1 ms or yield, to let main thread run\r\n        //  yield results in busy wait - which has better timing but kills battery life\r\n        if( settings.run && settings.busywait )\r\n            std::this_thread::yield();\r\n        else\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(1));\r\n\r\n        // start exclusive access\r\n        mtx.lock();\r\n\r\n        // run only if model is present\r\n        if( m )\r\n        {   \r\n            // record start time\r\n            double startwalltm = glfwGetTime();\r\n\r\n            //if (JDOF != m->nv)\r\n            //{\r\n            //    cout << \"Model dof mismatch!!!!  Model dof =\" << m->nv << endl<<endl;\r\n            //}\r\n\r\n            // running\r\n            if( settings.run )\r\n            {\r\n                if(initialpos == true)\r\n                {\r\n                    d->qpos[5] = 30.0 * DEG2RAD; // to avoid self collision\r\n                    // d->qpos[9] = 0.0 * DEG2RAD; // to avoid self collision\r\n                    initialpos = false;\r\n                }\r\n                else\r\n                {\r\n        \r\n        //             std::chrono::steady_clock::time_point st_start_time;\r\n\t\t// st_start_time = std::chrono::steady_clock::now();\r\n\t\t// double control_time_real_ = 0.0;\r\n                    // , d->xpos[27], d->xpos[28], d->xpos[29]\r\n                                        // cout<<\"xmat[81] : \" <<d->xmat[81]<<\",  \";\r\n                    // cout<<\"xmat[82] : \" <<d->xmat[82]<<\",  \";\r\n                    // cout<<\"xmat[83] : \" <<d->xmat[83]<<endl;\r\n\r\n                    // cout<<\"xmat[84] : \" <<d->xmat[84]<<\",  \";\r\n                    // cout<<\"xmat[85] : \" <<d->xmat[85]<<\",  \";\r\n                    // cout<<\"xmat[86] : \" <<d->xmat[86]<<endl;\r\n\r\n                    // cout<<\"xmat[87] : \" <<d->xmat[87]<<\",  \";\r\n                    // cout<<\"xmat[88] : \" <<d->xmat[88]<<\",  \";\r\n                    // cout<<\"xmat[89] : \" <<d->xmat[89]<<endl;\r\n                    // TaskControl.read(d->time, d->qpos, d->qvel, m->opt.timestep);\r\n                    Control.read(d->time, d->qpos, d->qvel, d->ncon);\r\n                    Control.control_mujoco();\r\n                    Control.write(d->ctrl);\r\n        //             control_time_real_ = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now() - st_start_time).count();\r\n\t\t// control_time_real_ = control_time_real_ / 1000;\r\n\t\t// cout<<control_time_real_<<\"ms\"<<endl;\r\n                    // cout<<\"xmat[81] : \" <<d->xmat[81]<<\",  \";\r\n                    // cout<<\"xmat[82] : \" <<d->xmat[82]<<\",  \";\r\n                    // cout<<\"xmat[83] : \" <<d->xmat[83]<<endl;\r\n\r\n                    // cout<<\"xmat[84] : \" <<d->xmat[84]<<\",  \";\r\n                    // cout<<\"xmat[85] : \" <<d->xmat[85]<<\",  \";\r\n                    // cout<<\"xmat[86] : \" <<d->xmat[86]<<endl;\r\n\r\n                    // cout<<\"xmat[87] : \" <<d->xmat[87]<<\",  \";\r\n                    // cout<<\"xmat[88] : \" <<d->xmat[88]<<\",  \";\r\n                    // cout<<\"xmat[89] : \" <<d->xmat[89]<<endl;\r\n                    // cout<<\"xpos[0] : \" <<d->xpos[0];//<<\",\"<<d->ctrl[8]<<\")  \"; \r\n                }\r\n\r\n                // record cpu time at start of iteration\r\n                double tmstart = glfwGetTime();\r\n\r\n\r\n                int sync_mode = 0;\r\n                if (sync_mode == 0) //strict time step\r\n                {\r\n                    // re-sync\r\n                    cpusync = tmstart;\r\n                    simsync = d->time;\r\n\r\n                    // clear old perturbations, apply new\r\n                    mju_zero(d->xfrc_applied, 6 * m->nbody);\r\n                    mjv_applyPerturbPose(m, d, &pert, 0);  // move mocap bodies only\r\n                    mjv_applyPerturbForce(m, d, &pert);\r\n\r\n                    // run single step, let next iteration deal with timing\r\n                    mj_step(m, d);\r\n                }\r\n                else if (sync_mode == 1) //for realtime (async)\r\n                {\r\n                    // out-of-sync (for any reason)\r\n                    if( d->time<simsync || tmstart<cpusync || cpusync==0 ||\r\n                    mju_abs((d->time-simsync)-(tmstart-cpusync))>syncmisalign )\r\n                    {\r\n                        // re-sync\r\n                        cpusync = tmstart;\r\n                        simsync = d->time;\r\n\r\n                        // clear old perturbations, apply new\r\n                        mju_zero(d->xfrc_applied, 6 * m->nbody);\r\n                        mjv_applyPerturbPose(m, d, &pert, 0);  // move mocap bodies only\r\n                        mjv_applyPerturbForce(m, d, &pert);\r\n\r\n                        // run single step, let next iteration deal with timing\r\n                        mj_step(m, d);\r\n                    }\r\n                    // in-sync\r\n                    else\r\n                    {\r\n                        // step while simtime lags behind cputime, and within safefactor\r\n                        while( (d->time-simsync)<(glfwGetTime()-cpusync) &&\r\n                               (glfwGetTime()-tmstart)<refreshfactor/vmode.refreshRate )\r\n                        {\r\n                            // clear old perturbations, apply new\r\n                            mju_zero(d->xfrc_applied, 6*m->nbody);                        \r\n\r\n                            mjv_applyPerturbPose(m, d, &pert, 0);  // move mocap bodies only\r\n                            mjv_applyPerturbForce(m, d, &pert);\r\n\r\n                            // run mj_step\r\n                            mjtNum prevtm = d->time;\r\n                            mj_step(m, d);\r\n\r\n                            // break on reset\r\n                            if( d->time<prevtm )\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                \r\n            }\r\n\r\n            // paused\r\n            else\r\n            {\r\n                // apply pose perturbation\r\n                mjv_applyPerturbPose(m, d, &pert, 1);      // move mocap and dynamic bodies\r\n\r\n                // run mj_forward, to update rendering and joint sliders\r\n                mj_forward(m, d);\r\n            }\r\n        }\r\n\r\n        // end exclusive access\r\n        mtx.unlock();\r\n    }\r\n}\r\n\r\n\r\n//-------------------------------- init and main ----------------------------------------\r\n\r\n// initalize everything\r\nvoid init(void)\r\n{\r\n    // print version, check compatibility\r\n    printf(\"MuJoCo Pro version %.2lf\\n\", 0.01*mj_version());\r\n    if( mjVERSION_HEADER!=mj_version() )\r\n        mju_error(\"Headers and library have different versions\");\r\n\r\n    // activate MuJoCo license\r\n\tmj_activate(\"../mujoco200/bin/mjkey.txt\");\r\n\r\n    // init GLFW, set timer callback (milliseconds)\r\n    if (!glfwInit())\r\n        mju_error(\"could not initialize GLFW\");\r\n    mjcb_time = timer;\r\n\r\n    // multisampling\r\n    glfwWindowHint(GLFW_SAMPLES, 4);\r\n    glfwWindowHint(GLFW_VISIBLE, 1);\r\n\r\n    // get videomode and save\r\n    vmode = *glfwGetVideoMode(glfwGetPrimaryMonitor());\r\n\r\n    // create window\r\n    window = glfwCreateWindow((2*vmode.width)/3, (2*vmode.height)/3, \r\n                              \"Simulate\", NULL, NULL);\r\n    if( !window )\r\n    {\r\n        glfwTerminate();\r\n        mju_error(\"could not create window\");\r\n    }\r\n\r\n    // save window position and size\r\n    glfwGetWindowPos(window, windowpos, windowpos+1);\r\n    glfwGetWindowSize(window, windowsize, windowsize+1);\r\n\r\n    // make context current, set v-sync\r\n    glfwMakeContextCurrent(window);\r\n    glfwSwapInterval(settings.vsync);\r\n\r\n    // init abstract visualization\r\n    mjv_defaultCamera(&cam);\r\n    mjv_defaultOption(&vopt);\r\n    profilerinit();\r\n    sensorinit();\r\n\r\n    // make empty scene\r\n    mjv_defaultScene(&scn);\r\n    mjv_makeScene(NULL, &scn, maxgeom);\r\n\r\n    // select default font\r\n    int fontscale = uiFontScale(window);\r\n    settings.font = fontscale/50 - 1;\r\n    \r\n    // make empty context\r\n    mjr_defaultContext(&con);\r\n    mjr_makeContext(NULL, &con, fontscale);\r\n\r\n    // set GLFW callbacks\r\n    uiSetCallback(window, &uistate, uiEvent, uiLayout);\r\n    glfwSetWindowRefreshCallback(window, render);\r\n    glfwSetDropCallback(window, drop);\r\n\r\n    // init state and uis\r\n    memset(&uistate, 0, sizeof(mjuiState));\r\n    memset(&ui0, 0, sizeof(mjUI));\r\n    memset(&ui1, 0, sizeof(mjUI));\r\n    ui0.spacing = mjui_themeSpacing(settings.spacing);\r\n    ui0.color = mjui_themeColor(settings.color);\r\n    ui0.predicate = uiPredicate;\r\n    ui0.rectid = 1;\r\n    ui0.auxid = 0;\r\n    ui1.spacing = mjui_themeSpacing(settings.spacing);\r\n    ui1.color = mjui_themeColor(settings.color);\r\n    ui1.predicate = uiPredicate;\r\n    ui1.rectid = 2;\r\n    ui1.auxid = 1;\r\n\r\n    // populate uis with standard sections\r\n    mjui_add(&ui0, defFile);\r\n    mjui_add(&ui0, defOption);\r\n    mjui_add(&ui0, defSimulation);\r\n    mjui_add(&ui0, defWatch);\r\n    uiModify(window, &ui0, &uistate, &con);\r\n    uiModify(window, &ui1, &uistate, &con);\r\n}\r\n\r\n// run event loop\r\nint main(int argc, const char** argv)\r\n{\r\n    // initialize everything\r\n    init();\t\r\n    char str[100] = \"../model/panda_arm_hand.xml\";\r\n    // char str[100] = \"../model/fr3.urdf\";\r\n\r\n    memcpy(filename, str, sizeof(str));\r\n    settings.loadrequest = 2;\r\n\r\n\tprintf(\"%s \", filename);\r\n\tprintf(\"%d \", settings.loadrequest);\r\n\r\n    // start simulation thread\r\n    std::thread simthread(simulate);\r\n\r\n    // event loop\r\n    while( !glfwWindowShouldClose(window) && !settings.exitrequest )\r\n    {\r\n        // start exclusive access (block simulation thread)\r\n        mtx.lock();\r\n\r\n        // load model (not on first pass, to show \"loading\" label)\r\n        if( settings.loadrequest==1 )\r\n            loadmodel();\r\n        else if( settings.loadrequest>1 )\r\n            settings.loadrequest = 1;\r\n\r\n        // handle events (calls all callbacks)\r\n        glfwPollEvents();\r\n\r\n        // prepare to render\r\n        prepare();\r\n\r\n        // end exclusive access (allow simulation thread to run)\r\n        mtx.unlock();\r\n\r\n        // render while simulation is running\r\n        render(window);\r\n    }\r\n\r\n    // stop simulation thread\r\n    settings.exitrequest = 1;\r\n    simthread.join();\r\n\r\n    // delete everything we allocated\r\n    uiClearCallback(window);\r\n    mj_deleteData(d); \r\n    mj_deleteModel(m);\r\n    mjv_freeScene(&scn);\r\n    mjr_freeContext(&con);\r\n\r\n    // deactive MuJoCo\r\n    mj_deactivate();\r\n\r\n    // terminate GLFW (crashes with Linux NVidia drivers)\r\n    #if defined(__APPLE__) || defined(_WIN32)\r\n        glfwTerminate();\r\n    #endif\r\n\r\n    return 0;\r\n}\r\n"
        }
    ]
}