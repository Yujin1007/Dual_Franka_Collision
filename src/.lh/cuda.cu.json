{
    "sourceFile": "cuda.cu",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1691629795424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1691629839825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1516,9 +1516,9 @@\n \n \n \n \n-\n+        alpha beta\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                },
                {
                    "date": 1691629900604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1516,9 +1516,12 @@\n \n \n \n \n-        alpha beta\n+        alpha  = alpha * 40000;\n+        beta = beta * 40000;\n+        cudaMemcpy(dev_x_goal, _goal_pos_cuda, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_x_goal, _goal_pos_cuda, sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                },
                {
                    "date": 1691629952584,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1518,10 +1518,10 @@\n \n \n         alpha  = alpha * 40000;\n         beta = beta * 40000;\n-        cudaMemcpy(dev_x_goal, _goal_pos_cuda, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_x_goal, _goal_pos_cuda, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                },
                {
                    "date": 1691629973928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1513,16 +1513,11 @@\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n-\n-\n-\n-        alpha  = alpha * 40000;\n-        beta = beta * 40000;\n         cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n-        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n+        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n         // {\n"
                },
                {
                    "date": 1691630038738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1909,8 +1909,11 @@\n \n     cudaFree(dev_jacobian);\n     cudaFree(dev_jacobian_transpose);\n \n+    cudaFree(dev_alpha);\n+    cudaFree(dev_beta);\n+\n     cudaError_t error = cudaGetLastError();\n     if (error != cudaSuccess) {\n         printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n         // 에러 처리 로직을 추가해야 합니다.\n"
                },
                {
                    "date": 1691630054026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1851,9 +1851,14 @@\n     cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n     cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n+    cudaMalloc((void**)&dev_alpha, sizeof(double));\n+    cudaMalloc((void**)&dev_beta, sizeof(double));\n+\n     \n+\n+    \n }\n \n void CudaTest::cuda_memory_free()\n {    \n"
                },
                {
                    "date": 1691630076633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -509,9 +509,9 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n+__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap, double *alpha, double *beta)\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n@@ -1852,13 +1852,9 @@\n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n     cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n     cudaMalloc((void**)&dev_alpha, sizeof(double));\n-    cudaMalloc((void**)&dev_beta, sizeof(double));\n-\n-    \n-\n-    \n+    cudaMalloc((void**)&dev_beta, sizeof(double));   \n }\n \n void CudaTest::cuda_memory_free()\n {    \n"
                },
                {
                    "date": 1691630107248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -514,10 +514,10 @@\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 =  alpha[0]// 80000.0; // 10000.0 (10.0) // rot\n+    double weight2 =  beta[0]// 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1691630147803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -514,10 +514,10 @@\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 =  alpha[0]// 80000.0; // 10000.0 (10.0) // rot\n-    double weight2 =  beta[0]// 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 =  alpha[0];// 80000.0; // 10000.0 (10.0) // rot\n+    double weight2 =  beta[0];// 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1691630165933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1513,10 +1513,10 @@\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n-        cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_alpha, alpha[0], sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_beta, beta[0], sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                },
                {
                    "date": 1691630191146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1154,9 +1154,9 @@\n         }\n     }\n }\n \n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double alpha, double beta, double *returnArray)\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *returnArray)\n { \n     // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n"
                },
                {
                    "date": 1691630211427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1513,10 +1513,10 @@\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n-        cudaMemcpy(dev_alpha, alpha[0], sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_beta, beta[0], sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                }
            ],
            "date": 1691629795424,
            "name": "Commit-0",
            "content": "#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include \"cuda.cuh\"\n\n#define THREADS_PER_BLOCK _sampling_num\n#define THREADS_PER_BLOCK2 _sampling_num\n\n// device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n\n\nCudaTest::CudaTest(void)\n{   \n}\n\nCudaTest::~CudaTest(void)\n{    \n    \n}\n\n__device__ double sigmoid(double x) {\n    return 1.0 / (1.0 + expf(-x));\n}\n\n__device__ double abs_cuda1(double x) {\n    if(x<0)\n    {\n        return -x;\n    }\n    else\n    {\n        return x;\n    }\n}\n\n__device__ double abs_cuda2(double x, double y) {\n    if(x-y<0)\n    {\n        return -x+y;\n    }\n    else\n    {\n        return x-y;\n    }\n}\n\n__device__ double pow2_cuda(double x) {\n    return x*x;\n}\n\n\n__device__ double norm2_vector3(double *x)\n{\n    double _norm2 = 0.0;\n    for(int i = 0; i<3; i++)\n    {\n        _norm2 = _norm2 + (x[i] * x[i]);\n    }\n    _norm2 = sqrt(_norm2);\n    return _norm2;\n}\n\n__device__ double calculateSingularValue(double* matrix) \n{\n    int row = threadIdx.y;\n    int col = threadIdx.x;\n    \n    // 3x3 행렬의 크기를 정의\n    int matrixSize = 3;\n    \n    // 행렬의 요소를 읽음\n    double element = matrix[row * matrixSize + col];\n    double singularValue = 0.0;\n    \n    // 행렬의 특잇값은 고유값의 제곱근이므로 제곱을 계산\n    element *= element;\n    \n    // 각 스레드마다 계산한 제곱된 특잇값을 공유 메모리에 저장\n    __shared__ double sharedData[9];\n    sharedData[row * matrixSize + col] = element;\n    \n    // 동기화\n    __syncthreads();\n    \n    // 공유 메모리의 값을 최대값으로 업데이트\n    if (threadIdx.x == 0 && threadIdx.y == 0) {\n        double maxVal = 0.0;\n        for (int i = 0; i < 9; i++) {\n            if (sharedData[i] > maxVal) {\n                maxVal = sharedData[i];\n            }\n        }\n        singularValue = sqrt(maxVal);\n    }\n    return singularValue;\n}\n\n__device__ void computeTransformationMatrix(double alpha, double a, double d, double theta, double* matrix) \n{\n    double cosTheta = cos(theta);\n    double sinTheta = sin(theta);\n    double cosAlpha = cos(alpha);\n    double sinAlpha = sin(alpha);\n\n    matrix[0] = cosTheta;\n    matrix[1] = -sinTheta;\n    matrix[2] = 0;\n    matrix[3] = a;\n\n    matrix[4] = sinTheta * cosAlpha;\n    matrix[5] = cosTheta * cosAlpha;\n    matrix[6] = -sinAlpha;\n    matrix[7] = -d * sinAlpha;\n\n    matrix[8] = sinTheta * sinAlpha;\n    matrix[9] = cosTheta * sinAlpha;\n    matrix[10] = cosAlpha;\n    matrix[11] = d * cosAlpha;\n    \n    matrix[12] = 0.0;\n    matrix[13] = 0.0;\n    matrix[14] = 0.0;\n    matrix[15] = 1.0;\n}\n\n__device__ void matrixMultiply_4x4(double *mat1, double *mat2, double *mat3)\n{\n    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[4] + mat1[2] * mat2[8] + mat1[3] * mat2[12];\n    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[5] + mat1[2] * mat2[9] + mat1[3] * mat2[13];\n    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[6] + mat1[2] * mat2[10] + mat1[3] * mat2[14];\n    mat3[3] = mat1[0] * mat2[3] + mat1[1] * mat2[7] + mat1[2] * mat2[11] + mat1[3] * mat2[15];\n\n    mat3[4] = mat1[4] * mat2[0] + mat1[5] * mat2[4] + mat1[6] * mat2[8] + mat1[7] * mat2[12];\n    mat3[5] = mat1[4] * mat2[1] + mat1[5] * mat2[5] + mat1[6] * mat2[9] + mat1[7] * mat2[13];\n    mat3[6] = mat1[4] * mat2[2] + mat1[5] * mat2[6] + mat1[6] * mat2[10] + mat1[7] * mat2[14];\n    mat3[7] = mat1[4] * mat2[3] + mat1[5] * mat2[7] + mat1[6] * mat2[11] + mat1[7] * mat2[15];\n\n    mat3[8] = mat1[8] * mat2[0] + mat1[9] * mat2[4] + mat1[10] * mat2[8] + mat1[11] * mat2[12];\n    mat3[9] = mat1[8] * mat2[1] + mat1[9] * mat2[5] + mat1[10] * mat2[9] + mat1[11] * mat2[13];\n    mat3[10] = mat1[8] * mat2[2] + mat1[9] * mat2[6] + mat1[10] * mat2[10] + mat1[11] * mat2[14];\n    mat3[11] = mat1[8] * mat2[3] + mat1[9] * mat2[7] + mat1[10] * mat2[11] + mat1[11] * mat2[15];\n\n    mat3[12] = mat1[12] * mat2[0] + mat1[13] * mat2[4] + mat1[14] * mat2[8] + mat1[15] * mat2[12];\n    mat3[13] = mat1[12] * mat2[1] + mat1[13] * mat2[5] + mat1[14] * mat2[9] + mat1[15] * mat2[13];\n    mat3[14] = mat1[12] * mat2[2] + mat1[13] * mat2[6] + mat1[14] * mat2[10] + mat1[15] * mat2[14];\n    mat3[15] = mat1[12] * mat2[3] + mat1[13] * mat2[7] + mat1[14] * mat2[11] + mat1[15] * mat2[15];\n}\n\n__device__ void matrixMultiply_3x3(double *mat1, double *mat2, double *mat3)\n{\n    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[3] + mat1[2] * mat2[6];\n    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[4] + mat1[2] * mat2[7];\n    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[5] + mat1[2] * mat2[8];\n\n    mat3[3] = mat1[3] * mat2[0] + mat1[4] * mat2[3] + mat1[5] * mat2[6];\n    mat3[4] = mat1[3] * mat2[1] + mat1[4] * mat2[4] + mat1[5] * mat2[7];\n    mat3[5] = mat1[3] * mat2[2] + mat1[4] * mat2[5] + mat1[5] * mat2[8];\n\n    mat3[6] = mat1[6] * mat2[0] + mat1[7] * mat2[3] + mat1[8] * mat2[6];\n    mat3[7] = mat1[6] * mat2[1] + mat1[7] * mat2[4] + mat1[8] * mat2[7];\n    mat3[8] = mat1[6] * mat2[2] + mat1[7] * mat2[5] + mat1[8] * mat2[8];\n}\n\n__device__ void rpy_from_transformationmatrix(double *RotMat, double *rpy)\n{\n    // rpy[1] = RotMat[8];\n    rpy[1] = -asin(RotMat[8]);\n    if(RotMat[8] > 1.0 - _threshold_cuda && RotMat[8] < 1.0 + _threshold_cuda)\n    {\n        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n        rpy[2] = 0.0;\n    }\n    else if (RotMat[8] < -1.0 + _threshold_cuda && RotMat[8] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n    {//Gimbal lock, pitch = 90deg\n        rpy[0] = atan2(RotMat[1], RotMat[2]);\n        rpy[2] = 0.0;\n    }\n    else //general solution\n    {\n        rpy[0] = atan2(RotMat[9], RotMat[10]);\n        rpy[2] = atan2(RotMat[4], RotMat[0]);\n    }\n}\n\n__device__ void rpy_from_rotationmatrix(double *RotMat, double *rpy)\n{\n    // rpy[1] = RotMat[8];\n    rpy[1] = -asin(RotMat[6]);\n    if(RotMat[6] > 1.0 - _threshold_cuda && RotMat[6] < 1.0 + _threshold_cuda)\n    {\n        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n        rpy[2] = 0.0;\n    }\n    else if (RotMat[6] < -1.0 + _threshold_cuda && RotMat[6] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n    {//Gimbal lock, pitch = 90deg\n        rpy[0] = atan2(RotMat[1], RotMat[2]);\n        rpy[2] = 0.0;\n    }\n    else //general solution\n    {\n        rpy[0] = atan2(RotMat[7], RotMat[8]);\n        rpy[2] = atan2(RotMat[3], RotMat[0]);\n    }\n}\n\n__device__ void determinant_6x6(double *matrix, double result)\n{\n    int tid = threadIdx.x;\n    int stride = blockDim.x;\n\n    double temp[6][6];\n    for (int i = 0; i < 6; i++) {\n        for (int j = 0; j < 6; j++) {\n            temp[i][j] = matrix[i * 6 + j];\n        }\n    }\n\n    for (int k = 0; k < 6 - 1; k++) {\n        for (int i = k + 1 + tid; i < 6; i += stride) {\n            double ratio = temp[i][k] / temp[k][k];\n            for (int j = k; j < 6; j++) {\n                temp[i][j] -= ratio * temp[k][j];\n            }\n        }\n        __syncthreads();\n    }\n\n    if (tid == 0) {\n        result = 1.0;\n        for (int i = 0; i < 6; i++) {\n            result *= temp[i][i];\n        }\n    }\n}\n\n__global__ void cal_jacobian(double *theta_table, double *_jacobian)\n{\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    // int index2 = index/_time_window;\n    int index3 = index*6*_JDOF;\n    // double theta[7];\n\n    if(index<_sampling_num )\n    {\n        \n        // for(int i = 0; i<_JDOF;)\n        // {\n        //     theta[i]= theta_table[(index*_JDOF*_time_window)+(_time_window*i)+(_time_window-1)];\n        // }\n\n        double cash = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        double cash_1 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        double cash_2 = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        double cash_3 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        double cash0 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        double cash0_1 = (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n        double cash1 = (sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n        double cash2 = ((-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]));\n        double cash2_2 = (cash2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n        double cash3 = ((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + cash*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n        double cash4 = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);    \n\n        _jacobian[index3 + 0] = ((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+(((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+((-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))-768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-632)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n        _jacobian[index3 + 1] = (176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cash+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+632)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n        _jacobian[index3 + 2] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 3] = (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*cash;\n        _jacobian[index3 + 4] = -cash0_1*cash1 + (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n        _jacobian[index3 + 5] = -cash0_1*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n        _jacobian[index3 + 6] = 0.0;\n\n        _jacobian[index3 + 7] = 11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400;\n        _jacobian[index3 + 8] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 9] = -(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) + (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 10] =  -(sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125)*cash;\n        _jacobian[index3 + 11] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*cash1 - (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n        _jacobian[index3 + 12] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) - (cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n        _jacobian[index3 + 13] = 0.0;\n\n        _jacobian[index3 + 14] = 0.0;\n        _jacobian[index3 + 15] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 16] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 17] = (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125);\n        _jacobian[index3 + 18] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])) + cash0_1*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n        _jacobian[index3 + 19] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + cash0_1*(cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n        _jacobian[index3 + 20] = 0.0;\n\n        _jacobian[index3 + 21] = 0.0;\n        _jacobian[index3 + 22] = -sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 23] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 24] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 25] = -(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4;\n        _jacobian[index3 + 26] = cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n        _jacobian[index3 + 27] = cash2_2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n\n        _jacobian[index3 + 28] = 0.0;\n        _jacobian[index3 + 29] = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 30] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 31] = cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        _jacobian[index3 + 32] = -(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n        _jacobian[index3 + 33] = ((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n        _jacobian[index3 + 34] = (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n\n        _jacobian[index3 + 35] = 1.0;\n        _jacobian[index3 + 36] = 0.0;\n        _jacobian[index3 + 37] = cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 38] = -cash;\n        _jacobian[index3 + 39] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n        _jacobian[index3 + 40] = (-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n        _jacobian[index3 + 41] = cash3*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - cash1*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n    }\n    //  __syncthreads();\n}\n\n__global__ void Transpose_Matrix_3x3(double *input, double *output)\n{\n    // printf(\"Transpose_Matrix_3x3 OK \\n\");\n    output[0] = input[0];\n    output[1] = input[3];\n    output[2] = input[6];\n\n    output[3] = input[1];\n    output[4] = input[4];\n    output[5] = input[7];\n\n    output[6] = input[2];\n    output[7] = input[5];\n    output[8] = input[8];\n}\n\n__global__ void state_update(double *a, double *b, double *c, double *d, double *e, double *_dt_cuda2){\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    int index2 = index % _time_window;\n    int index3 = index % (_time_window * _JDOF);\n    int joint_num = index3 / _time_window;\n\n    if (index2 == 0)\n    {\n        d[index] = b[joint_num] + (_dt_cuda * a[index]); // 속도\n        e[index] = c[joint_num] + (_dt_cuda * d[index]); // 위치\n    }\n    else\n    {\n        if(index2 >= _time_window-_dt2_window)\n        {\n            d[index] = _dt_cuda2[0] * a[index];\n            e[index] = 0.0;\n        }\n        else\n        {\n            d[index] = _dt_cuda * a[index];\n            e[index] = 0.0;\n        }\n        \n    }\n    // printf(\"state_update OK \\n\");\n    __syncthreads();\n}\n\n__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n{ \n    // printf(\"joint_limit_cost OK \\n\");\n    // vel pos cost goal\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    // int index2 = index % _time_window ;\n    int index3 = index % (_time_window*7);\n    int joint_num = index3 / _time_window;\n\n    double constraint_gain = 500000.0;//pow(10,6)\n    double vel_gain = 300.0;//pow(10,6)\n    if(now_gap[0] > gap_limit )\n    {\n        vel_gain =  0.0;\n    }\n    else\n    {\n        vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n    }\n    \n\n    cost_joint_limit[index]=0.0;\n\n    // if(index2 >= _time_window-5)\n    // {   \n        // if(now_gap[0] > 0.3)\n        // {\n        //     if(position[index] < min_joint_limit[joint_num])\n        //     {\n        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n        //     }\n\n        //     else if(position[index] > max_joint_limit[joint_num])\n        //     {\n        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n        //     }\n        // }\n        // else\n        // {\n        //     if(position[index] < min_joint_limit[joint_num])\n        //     {\n        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],min_joint_limit[joint_num]);\n        //     }\n\n        //     else if(position[index] > max_joint_limit[joint_num])\n        //     {\n        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],max_joint_limit[joint_num]);\n        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n        //     }\n        // }\n\n    // }\n    // else\n    // {\n        if(position[index] <= min_joint_limit[joint_num])\n        {\n            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n        }\n\n        else if(position[index] >= max_joint_limit[joint_num])\n        {\n            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n            // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n        }\n        else\n        {\n            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n        }\n        if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n        {\n            cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n        }\n        // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n        // {\n        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n        // }\n        // else\n        // {\n        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n        // }  \n\n        if(joint_num < 4)\n        {\n            // cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n        }\n        else\n        {\n            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n            cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n        }        \n        // cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n    // }\n    __syncthreads();\n}\n\n__global__ void cost_function_joint_control(double *d, double *e, double *f, double *g, double *position_sec1, double *position_sec2, double *velocity_lim, double *acc, double *prev_acc, double *min_joint_limit, double *max_joint_limit)\n{\n    // vel pos cost goal\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    int index3 = index % (_time_window*7);\n    int joint_num = index3 / _time_window;\n\n    double cost_pos =  abs_cuda2(e[index],g[joint_num]);// + pow(10,2);// * abs(_vel_state(i,j));// + abs(_acc_state(i,j));\n\tdouble cost_vel =  abs_cuda1(d[index]);\n    double cost_acc =  abs_cuda2(acc[index],prev_acc[index]);\n    double pos_gain = 10000.0;//pow(10,4)\n    double vel_gain = 100.0;//pow(10,1)\n    double constraint_gain = 10000000.0;//pow(10,6)\n\n    if(abs_cuda1(cost_pos) >  position_sec1[0])\n    {\n        f[index] = 10000.0 + pos_gain * cost_pos + vel_gain * cost_vel;// + 1.0 * cost_acc;\n        // printf(\"sec1\\n\");\n        // printf(\"sec1 : cost[%d] : %f \\n\", index,f[index]);\n        // printf(\"sec1 : pos[%d] : %f \\n\", index,e[index]);\n        // printf(\"sec1 : vel[%d] : %f \\n\", index,d[index]);\n        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n    }\n\t///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n\telse if(abs_cuda1(cost_pos) <= position_sec1[0] && abs_cuda1(cost_pos) > position_sec2[0])\n\t{\n\t\tf[index] = 1000.0 + pos_gain * cost_pos + vel_gain * cost_vel;\n        // printf(\"sec2\\n\");\n        // printf(\"sec2 : cost[%d] : %f \\n\", index,f[index]);\n        // printf(\"sec2 : pos[%d] : %f \\n\", index,e[index]);\n        // printf(\"sec2 : vel[%d] : %f \\n\", index,d[index]);\n        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n    }\n\t///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n\telse\n\t{\n\t\tf[index] = pos_gain * cost_pos + vel_gain * cost_vel;\n    }\n\n\t///////////////////// Velocity Limit Constraint ///////////////////////////////////////////////////\n\tif(abs_cuda1(cost_vel) > velocity_lim[0]) // 0.8\n\t{\n\t\tf[index] = f[index] + constraint_gain * cost_vel;\n\t}\n\n    ///////////////////// Joint Limit Constraint   ///////////////////////////////////////////////////\n    if(e[index] < min_joint_limit[joint_num])\n    {\n        f[index] = f[index] + constraint_gain * (e[index] - min_joint_limit[joint_num]) * (e[index] - min_joint_limit[joint_num]);\n    }\n\n    else if(e[index] > max_joint_limit[joint_num])\n    {\n        f[index] = f[index] + constraint_gain * (e[index] - max_joint_limit[joint_num]) * (e[index] - max_joint_limit[joint_num]);\n    }\n    __syncthreads();\n}\n\n__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n{\n    // printf(\"cost_function_task_space_control OK \\n\");\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    // int index2 = index % _time_window ;\n    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n    // double weight_manipul = 100.0;\n\n    if(index < _sampling_num * _time_window)\n    {\n        double rotation_EE_index[9];\n        for(int i = 0; i<9; i++)\n        {\n            rotation_EE_index[i] = rotation_EE[index*9+i];    \n        }\n\n        double PosEE_index[3];\n        for(int i = 0; i<3; i++)\n        {\n            PosEE_index[i] = position[index*3+i];\n        }\n        PosEE_index[2] = PosEE_index[2] - 0.01;\n\n        double RotGoalT_x_RotEE[9];\n        double RotGap[3];\n\n\n        // double RotGoalT_x_PosEE[3];\n        // double RotGoalT_x_PosGoal[3];\n        double PosGap[3];\n        double PosGap_2 = 0.0;\n\n        matrixMultiply_3x3(rotation_goal_T, rotation_EE_index, RotGoalT_x_RotEE);\n        rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n\n        double cost1 = 0.0;\n        double cost2 = 0.0;\n        double cost1_2 = 0.0;        \n        double cost2_2 = 0.0;\n        double cost3 = 0.0;\n        // double cost2 = 0.0;\n\n        for(int i = 0;i<3; i++)\n        {\n            PosGap[i] = abs(PosEE_index[i]-g[i]);\n            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n            // cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n\n            PosGap_2 += abs(PosGap[i]);\n\n            // if(PosGap[i] > 1)\n            // {\n            //     cost2_2 = cost2_2 + pow2_cuda(PosGap[i]);\n            // }\n            // else\n            // {\n            //     cost2_2 = cost2_2 + PosGap[i];\n            // }\n            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n        }\n\n        if(PosGap_2 > gap_limit )\n        {\n            cost3 = weight1 * 3.14 * 3 * 2;\n            weight1 =  0.0;            \n        }\n        // else\n        // {\n        //     // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n        // }\n\n        // if(cost1_2 > 1)\n        // {\n        //     cost1_2 = pow2_cuda(cost1_2);\n        // }\n        // cost1 = cost1_2 + cost2_2;\n        // if(cost1 > 2.0)\n        // {\n        //     f[index] = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n        // }\n        // else if(cost1 <= 2.0 && cost1 > 1.0)\n        // {\n        //     f[index] = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n        // }\n        // else\n        // {\n        //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n        // }\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        if(cost2_2 >  position_sec1[0])\n        {\n            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n            // cost2 = weight_manipul * (1-_manipulability[index]);\n        }\n        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n        {\n            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n            // cost2 = weight_manipul * (1-_manipulability[index]);\n        }\n        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n        else\n        {\n            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n            // cost2 = (1-_manipulability[index]);\n        }\n        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n        if(sqrt(_manipulability[index])<= 0.1)\n        {\n            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n        }\n        // f[index] = cost1 + cost2 + cost3;\n        f[index] = cost1 + cost3;\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n        // if(now_gap[0] > 1.0)\n        // {\n        //     if(index2 < _time_window-5)\n        //     {\n        //         f[index] = 0.0;\n        //     }\n        // }\n        // else\n        // {\n        //     if(index2 >= _time_window-5)\n        //     {\n        //         f[index] = 0.0;\n        //     }\n        // }\n    }    \n    __syncthreads();\n}\n\n__global__ void generate_random2(double* _A, double* _mean_matrix, double* _matrix_for_cuda)\n{\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    int index3 = index % (_time_window*_JDOF);\n    int joint_num = index3 / _time_window;\n    // curandState localState = state[index%_time_window];\n    curandState state;\n    \n    // 현재 스레드의 인덱스로 상태 정보 초기화\n    curand_init(0, index, 0, &state);\n    // double rand_val;\n\n    // rand_val = curand_normal(&localState) * 1.0 + _A[joint_num];\n    // _matrix_for_cuda[index] = rand_val;\n    if (index % _time_window == 0)\n    {\n        // if(index == 0)\n        // {\n        //     _matrix_for_cuda[index] = 0.0;\n        // }\n        // else\n        // {\n            _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n            // printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n            // if(joint_num>=4)\n            // {\n            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n            // }\n            // else\n            // {\n            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n            // }            \n        // }\n        if(abs_cuda1(_matrix_for_cuda[index])>100)\n        {\n            _matrix_for_cuda[index] = 0.0;   \n        }\n    }\n    // printf(\"generate_random2 OK \\n\");\n    __syncthreads();\n}\n\n__global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n{\n    // printf(\"GetBodyRotationMatrix OK \\n\");\n    double Roll = xyzrpy_goal[3];\n    double Pitch = xyzrpy_goal[4];\n    double Yaw = xyzrpy_goal[5];\n\n    double R_yaw[9];\n    R_yaw[0] = cos(Yaw);\n    R_yaw[1] = -sin(Yaw);\n    R_yaw[2] = 0.0;\n    R_yaw[3] = sin(Yaw);\n    R_yaw[4] = cos(Yaw);\n    R_yaw[5] = 0.0;\n    R_yaw[6] = 0.0;\n    R_yaw[7] = 0.0;\n    R_yaw[8] = 1.0;\n\n    double R_pitch[9];\n    R_pitch[0] = cos(Pitch);\n    R_pitch[1] = 0.0;\n    R_pitch[2] = sin(Pitch);\n    R_pitch[3] = 0.0;\n    R_pitch[4] = 1.0;\n    R_pitch[5] = 0.0;\n    R_pitch[6] = -sin(Pitch);\n    R_pitch[7] = 0.0;\n    R_pitch[8] = cos(Pitch);\n\n    double R_roll[9];\n    R_roll[0] = 1.0;\n    R_roll[1] = 0.0;\n    R_roll[2] = 0.0;\n    R_roll[3] = 0.0;\n    R_roll[4] = cos(Roll);\n    R_roll[5] = -sin(Roll);\n    R_roll[6] = 0.0;\n    R_roll[7] = sin(Roll);\n    R_roll[8] = cos(Roll);\n    \n    double tmp_mat3x3[9];\n    matrixMultiply_3x3(R_yaw, R_pitch, tmp_mat3x3);\n    matrixMultiply_3x3(tmp_mat3x3, R_roll, RGyro);\n}\n\n__global__ void prev_computeForwardKinematics(double* FK_a, double* FK_d, double* FK_alpha, double* prev_q, double* position_EE, double* orientation_EE) \n{\n    double transformationMatrix[16];\n    double transformationMatrix2[16];\n    double tempMatrix[16];\n    double tempMatrix2[16];\n    \n    computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], prev_q[0], transformationMatrix);\n    computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], prev_q[1], tempMatrix);\n    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n    computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], prev_q[2], tempMatrix2);\n    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n    computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], prev_q[3], tempMatrix);\n    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n    computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], prev_q[4], tempMatrix2);\n    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n    computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], prev_q[5], tempMatrix);\n    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n    computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], prev_q[6], tempMatrix2);\n    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n    // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n    // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n    position_EE[0] = transformationMatrix[3];\n    position_EE[1] = transformationMatrix[7];\n    position_EE[2] = transformationMatrix[11];\n    //rpy\n    double tempVec[3];\n    rpy_from_transformationmatrix(transformationMatrix, tempVec);\n    orientation_EE[0] = tempVec[0];\n    orientation_EE[1] = tempVec[1];\n    orientation_EE[2] = tempVec[2];\n    // printf(\"prev_computeForwardKinematics OK \\n\");\n}\n\n__global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n{\n    // printf(\"computeForwardKinematics OK \\n\");\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    // int index3 = index % (_time_window*7);\n    // int joint_num = index3 / _time_window;\n    // 각 변환 행렬 계산\n\n    if(index < _sampling_num)\n    {\n        for(int i = 0; i<_time_window; i++)\n        {\n            double transformationMatrix[16];\n            double transformationMatrix2[16];\n\n            double tempMatrix[16];\n            double tempMatrix2[16];\n            double man_6x6[36];\n\n            double p0[3];\n            double p1[3];\n            double p2[3];\n            double p3[3];\n            double p4[3];\n            double p5[3];\n            double p6[3];\n\n            double z0[3];\n            double z1[3];\n            double z2[3];\n            double z3[3];\n            double z4[3];\n            double z5[3];\n            double z6[3];\n\n            double t0[3];\n            double t1[3];\n            double t2[3];\n            double t3[3];\n            double t4[3];\n            double t5[3];\n\n            p0[0] = 0.0;\n            p0[1] = 0.0;\n            p0[2] = FK_d[0];\n\n            z0[0] = 0.0;\n            z0[1] = 0.0;\n            z0[2] = 1.0;      \n            \n            computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], jointAngles[index*_time_window*_JDOF+i], transformationMatrix);\n\n            computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], jointAngles[index*_time_window*_JDOF+_time_window+i], tempMatrix);\n            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n            p1[0] = transformationMatrix2[3];\n            p1[1] = transformationMatrix2[7];\n            p1[2] = transformationMatrix2[11];\n            z1[0] = transformationMatrix2[2];\n            z1[1] = transformationMatrix2[6];\n            z1[2] = transformationMatrix2[10];\n\n            computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], jointAngles[index*_time_window*_JDOF+2*_time_window+i], tempMatrix2);\n            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n            p2[0] = transformationMatrix[3];\n            p2[1] = transformationMatrix[7];\n            p2[2] = transformationMatrix[11];\n            z2[0] = transformationMatrix[2];\n            z2[1] = transformationMatrix[6];\n            z2[2] = transformationMatrix[10];\n\n            computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], jointAngles[index*_time_window*_JDOF+3*_time_window+i], tempMatrix);\n            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n            p3[0] = transformationMatrix2[3];\n            p3[1] = transformationMatrix2[7];\n            p3[2] = transformationMatrix2[11];\n            z3[0] = transformationMatrix2[2];\n            z3[1] = transformationMatrix2[6];\n            z3[2] = transformationMatrix2[10];\n\n            computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], jointAngles[index*_time_window*_JDOF+4*_time_window+i], tempMatrix2);\n            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n            p4[0] = transformationMatrix[3];\n            p4[1] = transformationMatrix[7];\n            p4[2] = transformationMatrix[11];\n            z4[0] = transformationMatrix[2];\n            z4[1] = transformationMatrix[6];\n            z4[2] = transformationMatrix[10];\n\n            computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], jointAngles[index*_time_window*_JDOF+5*_time_window+i], tempMatrix);\n            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n            p5[0] = transformationMatrix2[3];\n            p5[1] = transformationMatrix2[7];\n            p5[2] = transformationMatrix2[11];\n            z5[0] = transformationMatrix2[2];\n            z5[1] = transformationMatrix2[6];\n            z5[2] = transformationMatrix2[10];\n\n            computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], jointAngles[index*_time_window*_JDOF+6*_time_window+i], tempMatrix2);\n            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n            p6[0] = transformationMatrix[3];\n            p6[1] = transformationMatrix[7];\n            p6[2] = transformationMatrix[11];\n            z6[0] = transformationMatrix[2];\n            z6[1] = transformationMatrix[6];\n            z6[2] = transformationMatrix[10];\n\n            t0[0] =  p6[0]-p0[0];\n            t0[1] =  p6[1]-p0[1];\n            t0[2] =  p6[2]-p0[2];\n\n            t1[0] =  p6[0]-p1[0];\n            t1[1] =  p6[1]-p1[1];\n            t1[2] =  p6[2]-p1[2];\n\n            t2[0] =  p6[0]-p2[0];\n            t2[1] =  p6[1]-p2[1];\n            t2[2] =  p6[2]-p2[2];\n\n            t3[0] =  p6[0]-p3[0];\n            t3[1] =  p6[1]-p3[1];\n            t3[2] =  p6[2]-p3[2];\n\n            t4[0] =  p6[0]-p4[0];\n            t4[1] =  p6[1]-p4[1];\n            t4[2] =  p6[2]-p4[2];\n\n            t5[0] =  p6[0]-p5[0];\n            t5[1] =  p6[1]-p5[1];\n            t5[2] =  p6[2]-p5[2];            \n\n            jacobian_matrix[index*_time_window*42+i*42+0] = z0[1]*t0[2]-z0[2]*t0[1];\n            jacobian_matrix[index*_time_window*42+i*42+7] = z0[2]*t0[0]-z0[0]*t0[2];\n            jacobian_matrix[index*_time_window*42+i*42+14] = z0[0]*t0[1]-z0[1]*t0[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+1] = z1[1]*t1[2]-z1[2]*t1[1];\n            jacobian_matrix[index*_time_window*42+i*42+8] = z1[2]*t1[0]-z1[0]*t1[2];\n            jacobian_matrix[index*_time_window*42+i*42+15] = z1[0]*t1[1]-z1[1]*t1[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+2] = z2[1]*t2[2]-z2[2]*t2[1];\n            jacobian_matrix[index*_time_window*42+i*42+9] = z2[2]*t2[0]-z2[0]*t2[2];\n            jacobian_matrix[index*_time_window*42+i*42+16] = z2[0]*t2[1]-z2[1]*t2[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+3] = z3[1]*t3[2]-z3[2]*t3[1];\n            jacobian_matrix[index*_time_window*42+i*42+10] = z3[2]*t3[0]-z3[0]*t3[2];\n            jacobian_matrix[index*_time_window*42+i*42+17] = z3[0]*t3[1]-z3[1]*t3[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+4] = z4[1]*t4[2]-z4[2]*t4[1];\n            jacobian_matrix[index*_time_window*42+i*42+11] = z4[2]*t4[0]-z4[0]*t4[2];\n            jacobian_matrix[index*_time_window*42+i*42+18] = z4[0]*t4[1]-z4[1]*t4[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+5] = z5[1]*t5[2]-z5[2]*t5[1];\n            jacobian_matrix[index*_time_window*42+i*42+12] = z5[2]*t5[0]-z5[0]*t5[2];\n            jacobian_matrix[index*_time_window*42+i*42+19] = z5[0]*t5[1]-z5[1]*t5[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+6] = 0.0;\n            jacobian_matrix[index*_time_window*42+i*42+13] = 0.0;\n            jacobian_matrix[index*_time_window*42+i*42+20] = 0.0;\n\n            jacobian_matrix[index*_time_window*42+i*42+21] = z0[0];\n            jacobian_matrix[index*_time_window*42+i*42+28] = z0[1];\n            jacobian_matrix[index*_time_window*42+i*42+35] = z0[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+22] = z1[0];\n            jacobian_matrix[index*_time_window*42+i*42+29] = z1[1];\n            jacobian_matrix[index*_time_window*42+i*42+36] = z1[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+23] = z2[0];\n            jacobian_matrix[index*_time_window*42+i*42+30] = z2[1];\n            jacobian_matrix[index*_time_window*42+i*42+37] = z2[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+24] = z3[0];\n            jacobian_matrix[index*_time_window*42+i*42+31] = z3[1];\n            jacobian_matrix[index*_time_window*42+i*42+38] = z3[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+25] = z4[0];\n            jacobian_matrix[index*_time_window*42+i*42+32] = z4[1];\n            jacobian_matrix[index*_time_window*42+i*42+39] = z4[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+26] = z5[0];\n            jacobian_matrix[index*_time_window*42+i*42+33] = z5[1];\n            jacobian_matrix[index*_time_window*42+i*42+40] = z5[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+27] = z6[0];\n            jacobian_matrix[index*_time_window*42+i*42+34] = z6[1];\n            jacobian_matrix[index*_time_window*42+i*42+41] = z6[2];\n            \n            for(int l = 0; l<6; l++)\n            {\n                for(int j = 0; j<6; j++)\n                {\n                    man_6x6[l*6+j] = 0.0;\n                    for(int k = 0; k<7; k++)\n                    {\n                        man_6x6[l*6+j] = man_6x6[l*6+j] + (jacobian_matrix[index*_time_window*42+i*42+l*7+k] * jacobian_matrix[index*_time_window*42+i*42+j*7+k]);\n                    }                \n                }\n            }\n            determinant_6x6(man_6x6,_manipulability[index*_time_window+i]);\n            // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n\n            // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n\n            transformationMatrix_3x3[index*_time_window*9+i*9] = transformationMatrix[0];\n            transformationMatrix_3x3[index*_time_window*9+i*9+1] = transformationMatrix[1];\n            transformationMatrix_3x3[index*_time_window*9+i*9+2] = transformationMatrix[2];\n\n            transformationMatrix_3x3[index*_time_window*9+i*9+3] = transformationMatrix[4];\n            transformationMatrix_3x3[index*_time_window*9+i*9+4] = transformationMatrix[5];\n            transformationMatrix_3x3[index*_time_window*9+i*9+5] = transformationMatrix[6];\n\n            transformationMatrix_3x3[index*_time_window*9+i*9+6] = transformationMatrix[8];\n            transformationMatrix_3x3[index*_time_window*9+i*9+7] = transformationMatrix[9];\n            transformationMatrix_3x3[index*_time_window*9+i*9+8] = transformationMatrix[10];\n\n            position_EE[index*_time_window*3+i*3] = transformationMatrix[3];\n            position_EE[index*_time_window*3+i*3+1] = transformationMatrix[7];\n            position_EE[index*_time_window*3+i*3+2] = transformationMatrix[11];\n\n            //rpy\n            double tempVec[3];\n            rpy_from_transformationmatrix(transformationMatrix, tempVec);\n            orientation_EE[index*_time_window*3+i*3] = tempVec[0];\n            orientation_EE[index*_time_window*3+i*3+1] = tempVec[1];\n            orientation_EE[index*_time_window*3+i*3+2] = tempVec[2];\n            \n            if(i == 0)\n            {\n                velocity_EE[index*_time_window*3+i*3] = (transformationMatrix[3] - prev_x[0]) / _dt_cuda;\n                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - prev_x[1]) / _dt_cuda;\n                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - prev_x[2]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3] = (tempVec[0] - prev_r[0]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - prev_r[1]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - prev_r[2]) / _dt_cuda;\n            }\n            else\n            {\n                velocity_EE[index*_time_window*3+i*3+0] = (transformationMatrix[3] - position_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - position_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - position_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+0] = (tempVec[0] - orientation_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - orientation_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - orientation_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n            }            \n        }    \n    }\n    __syncthreads();\n}\n\n__global__ void forwardPropagation(double *inputs, double *weights0, double *weights1, double *weights2, double *weights3, double *weights4, double *weights5, double *outputs) \n{\n    // printf(\"forwardPropagation OK \\n\");\n    int tid = threadIdx.x + blockIdx.x * blockDim.x;\n    \n    double hidden0[_nodes_cuda];\n    double hidden1[_nodes_cuda];\n    \n    if (tid < _sampling_num) {\n        for (int j = 0; j < _nodes_cuda; j++) {\n            hidden0[j] = 0.0;\n        }\n    \n        for (int j = 0; j < _nodes_cuda; j++) {\n            hidden1[j] = 0.0;\n        }\n        \n        for (int j = 0; j < _nodes_cuda; j++) {\n            for (int i = 0; i < _JDOF; i++) {\n                hidden0[j] += inputs[tid * _JDOF + i] * weights0[i * _nodes_cuda + j];\n            }\n            \n            hidden0[j] += weights1[j];\n            \n            if (hidden0[j] <= 0) {\n                hidden0[j] = 0.0;\n            }\n        }\n        \n        for (int j = 0; j < _nodes_cuda; j++) {\n            for (int i = 0; i < _nodes_cuda; i++) {\n                hidden1[j] += hidden0[i] * weights2[i * _nodes_cuda + j];\n            }\n            \n            hidden1[j] += weights3[j];\n            \n            if (hidden1[j] <= 0) {\n                hidden1[j] = 0.0;\n            }\n        }\n    \n        double output1 = 0.0;\n    \n        for (int i = 0; i < _nodes_cuda; i++) {\n            output1 += hidden1[i] * weights4[i];\n        }\n    \n        output1 += weights5[0];\n        output1 = sigmoid(output1);\n    \n        outputs[tid] = output1;\n    }\n    __syncthreads();\n}\n\n__global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n{\n    // printf(\"calculate_inputs OK \\n\");\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n\n    if (index < _JDOF * _sampling_num)\n    {\n        inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n\n        if (inputs[index] > 1)\n        {\n            inputs[index] = 1;\n        }\n        else if (inputs[index] < -1)\n        {\n            inputs[index] = -1;\n        }\n    }\n    __syncthreads();\n}\n\n__global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n{\n    // printf(\"if_find_solution OK \\n\");\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    if(index < _sampling_num)\n    {\n        for(int i = 0; i<_time_window; i++)\n        {\n            double tmp_p = 0.0;\n            tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n            tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n            tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n\n            double rotation_EE_index[9];\n            for(int j = 0; j<9; j++)\n            {\n                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n            }\n\n            double RotGoalT_x_RotEE[9];\n            double RotGap[3];\n\n            matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n            rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n\n            double tmp_p2 = 0.0;\n            tmp_p2 = abs_cuda1(RotGap[0]);\n            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n\n            find_sol[index] = 0;\n            if(tmp_p <= 0.03);// && tmp_p2 <= 0.2)\n            {\n                for(int j = 0; j<_JDOF; j++)\n                {\n                    if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n                    {\n                        break;\n                    }\n                    else if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] >= max_joint_limit[j])\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        find_sol[index] = 1;\n                        // break;\n                    }\n                }\n                if(find_sol[index] == 1)\n                {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double alpha, double beta, double *returnArray)\n{ \n    // cout<<\"cuda code start\"<<endl;\n    // _dt_cuda2[0] = 0.5;\n    // for(int i = 0; i<6; i++)\n    // {\n    //     cout<<_goal_pos_cuda[i]<<endl;    \n    // }\n    \n    prev_x_cost = 0.0;\n    now_pos_gap[0] = 0.0;\n    for(int i = 0; i<3; i++)\n    {\n        now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n        // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n    }\n    // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n    // {\n    //     _dt_cuda2[0] = now_pos_gap[0];\n    // }\n    ////////////////////////////////////////////////////////////////\n    // if(found_goal == 1)\n    // {\n    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n    //     {\n    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n    //     }\n    //     else if(now_pos_gap[0] <= position_sec2[0])\n    //     {\n    //         _dt_cuda2[0] = _dt_cuda;\n    //     }\n    //     else if(now_pos_gap[0] >= 1.0)\n    //     {\n    //         _dt_cuda2[0] = 0.7;\n    //     }\n    // }\n    // else\n    // {\n    //     _dt_cuda2[0] = 0.7;\n    // }\n    // found_goal = 0;\n    // if(_dt_cuda2[0] != 0.7)\n    // {\n    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n    // }\n    //////////////////////////////////////////////////////////////\n    _sol_cost = _sol_cost / 5000;\n    // 200/\n\n    if(_sol_cost > 700)\n    {\n        _dt_cuda2[0] = 0.5;\n    }\n    else if(_sol_cost <= 700 && _sol_cost > 1)\n    {\n        _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n            //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n            // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n        // _dt_cuda2[0] = 0.003;\n    }\n    else\n    {\n        _dt_cuda2[0] = _dt_cuda;\n    }\n    // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n    // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n\n    reset_check = 0;\n    for(int i = 0; i<_JDOF; i++)\n    {\n        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n        {            \n            reset_check = 1;\n            break;\n        }\n    }\n    if(reset_check == 1)\n    {\n        for(int i = 0; i<_JDOF; i++)\n        {        \n            _q_des[i] = _init_pos[i];\n            _qdot_des[i] = _init_vel[i];\n            _A[i] = 0.0;\n        }\n    }\n    // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n    \n    dim3 blockDim(N/_time_window, 1, 1);\n    dim3 gridDim(_time_window, 1, 1);\n    dim3 gridDim2(_sampling_num, 1);\n    dim3 blockDim2(1, 1);\n    dim3 blockSize(1, 1);\n    dim3 gridSize(1, 1);\n    dim3 blockSize2(1, 1);\n    dim3 gridSize2(_sampling_num * _time_window, 1);\n\n    if(control_mode == 0)\n    {\n        cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n\n        for(int i = 0; i<N; i++)\n        {\n            int index222 = i / _time_window;\n            if((i%_time_window) != 0)\n            {\n                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n            }\n        }\n\n        // _dt_cuda2\n        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n        \n        for(int i = 0; i<N; i++)\n        {\n            if((i%_time_window) != 0)\n            {\n                d[i] = d[i-1] + d[i];\n                e[i] = e[i-1] + d[i] * _dt_cuda;\n            }\n        }\n\n        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n\n        cudaMemcpy(dev_q_goal, _goal_pos_cuda, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n\n        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n\n        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n\n        cost_function_joint_control <<< gridDim, blockDim>>> (dev_d, dev_e, dev_cost, dev_q_goal, dev_position_sec1, dev_position_sec2, dev_velocity_lim, dev__matrix_for_cuda, dev__prev_matrix_for_cuda, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost);\n        \n        cudaMemcpy(f, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n\n        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n        // cudaDeviceSynchronize();\n\n        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n\n        \n        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();    \n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _return_cost[i] = 0.0;\n            for(int j = 0; j<_JDOF; j++)\n            {\n                for(int k = 0; k<_time_window; k++)\n                {\n                    _return_cost[i] = _return_cost[i] + f[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                }\n            }\n            if(outputs[i] > 0.5)\n            {\n                _return_cost[i] = _return_cost[i] + outputs[i] * pow(10,6);\n            }\n            _return_cost[i] = _return_cost[i] / _JDOF;\n        }\n\n        _min_cost = 1000000000000000.0;\n        weight_sum = 0.0;\n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _cost[i] = _return_cost[i];\n            if(_min_cost > _cost[i])\n            {\n                _min_cost = _cost[i];\n            }\n        }\n        memset(_weighted_A, 0, _JDOF * sizeof(double));\n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _cost[i] = _cost[i] - _min_cost;\n            if(_cost[i]<100)\n            {\n                _cost[i] = exp(-_cost[i]);\t\t\n                weight_sum = weight_sum + _cost[i];\n                for(int j = 0; j<_JDOF; j++)\n                {\n                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n                }\n            }\n        }\n        for(int j = 0; j<_JDOF; j++)\n        {\n            _weighted_A[j] /=  weight_sum;\n            _A[j] = _weighted_A[j];\n            // if(_A[j] > 10.0)\n            // {\n            //     _A[j] = 10.0;\n            // }\n            // else if(_A[j] < -10.0)\n            // {\n            //     _A[j] = -10.0;\n            // }\n        }\n        \n        for(int i = 0; i<_JDOF; i++)\n        {\n            returnArray[(_JDOF*2)+i] = _weighted_A[i];\n            returnArray[_JDOF+i] = _qdot_des[i] + (_weighted_A[i] * _dt_cuda);\n            returnArray[i] = _q_des[i] + (_qdot_des[i] * _dt_cuda);\n\n            _q_des[i] = returnArray[i];\n            _qdot_des[i] = returnArray[_JDOF+i];\n        }\n    }\n\n    else if(control_mode == 1)\n    {\n        // for(int i= 0; i<7; i++)\n        // {\n        //     cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n        // }\n        \n        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n        for(int i = 0; i<N; i++)\n        {\n            int index222 = i / _time_window;\n            if((i%_time_window) != 0)\n            {   \n                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n                if((i%_time_window) >= _time_window-_dt2_window)\n                {\n                    _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n                }                \n            }\n            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n        }\n\n        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev__matrix_for_cuda, _matrix_for_cuda, N*sizeof(double), cudaMemcpyHostToDevice);\n        \n        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n\n        cudaDeviceSynchronize();\n        for(int i = 0; i<N; i++)\n        {\n            if((i%_time_window) != 0)\n            {\n                if((i%_time_window) >= _time_window-_dt2_window)\n                {\n                    d[i] = d[i-1] + d[i];\n                    e[i] = e[i-1] + d[i] * _dt_cuda2[0];\n                }\n                else\n                {\n                    d[i] = d[i-1] + d[i];\n                    e[i] = e[i-1] + d[i] * _dt_cuda;\n                }\n            }\n        }\n\n        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n        cudaDeviceSynchronize();\n\n        // cout<<\"222222222222222222222222\"<<endl;\n        // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        // cudaDeviceSynchronize();\n        // for(int k = 0 ;k <_sampling_num; k++)\n        // {\n        //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n        //     for(int i = 0; i<42; i++)\n        //     {\n        //         if(i%7 == 6)\n        //         {\n        //             cout<<jacobian[i+42*k]<<endl;    \n        //         }\n        //         else\n        //         {\n        //             cout<<jacobian[i+42*k]<<\" \";\n        //         }            \n        //     }\n        // }        \n        \n        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n\n\n        // cout<<\"CUDA manipulability\"<<endl;\n        // for(int i = 0; i<N/_JDOF; i++)\n        // {\n        //     cout<<\"manipulability ith : \"<<i<<manipulability[i]<<endl;\n        // }\n        cudaMemcpy(dev_FK_a, FK_a, 9*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n\n        prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n        cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n\n        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n        cudaDeviceSynchronize();\n        \n        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_cen_joint_position, _cen_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n\n        cudaMemcpy(dev_x_goal, _goal_pos_cuda, 6*sizeof(double), cudaMemcpyHostToDevice);\n\n        GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n        // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n        Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n\n        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n        cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n        \n\n\n\n\n\n        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n        // for(int i = 0; i<_sampling_num * _time_window; i++)\n        // {\n        //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n        // }\n\n        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n\n        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n        // {\n        //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n        // }\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n\n        // for(int i = 0; i<_sampling_num; i++)\n        // {\n        //     if(outputs[i]>0.5)\n        //     {\n        //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n        //     }\n        // }\n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _return_cost[i] = 0.0;\n            for(int j = 0; j<_JDOF; j++)\n            {\n                for(int k = 0; k<_time_window; k++)\n                {\n                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                }\n                // if(j == _JDOF-1)\n                // {\n                //     _return_cost[i] = _return_cost[i] / _JDOF;\n                // }\n            }\n            // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n\n            for(int j = 0 ; j<_time_window; j++)\n            {\n                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n            }\n            if(found_goal_list[i] == 1)\n            {\n                if(outputs[i] >= 0.5)\n                {\n                    found_goal_list[i] = 0;\n                }\n            }\n            if(outputs[i] > 0.5)\n            {\n                _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n            }\n            _return_cost[i] = _return_cost[i] / _JDOF;\n            // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n            if(found_goal_list[i] == 1)\n            {\n                found_goal = 1;\n                // cout<<\"??\"<<endl;\n                // _return_cost[i] = _return_cost[i];\n            }\n            // else\n            // {\n            //     _return_cost[i] = _return_cost[i] + 100.0;\n            // }\n        }\n\n        _min_cost = 1000000000000000.0;\n        weight_sum = 0.0;\n        // _sol_cost = 0.0;\n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _cost[i] = _return_cost[i];\n            if(_min_cost > _cost[i])\n            {\n                _min_cost = _cost[i];\n            }\n        }\n        _sol_cost = _min_cost;\n        memset(_weighted_A, 0, _JDOF * sizeof(double));\n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _cost[i] = _cost[i] - _min_cost;\n            if(_cost[i]<100)\n            {\n                _cost[i] = exp(-_cost[i]);\t\t\n                weight_sum = weight_sum + _cost[i];\n                for(int j = 0; j<_JDOF; j++)\n                {\n                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n                }\n            }\n        }\n        for(int j = 0; j<_JDOF; j++)\n        {\n            _weighted_A[j] /=  weight_sum;\n            _A[j] = _weighted_A[j];\n            // if(_A[j] > 10.0)\n            // {\n            //     _A[j] = 10.0;\n            // }\n            // else if(_A[j] < -10.0)\n            // {\n            //     _A[j] = -10.0;\n            // }\n        }\n\n        // for(int i = 0; i<_JDOF; i++)\n        // {\n        //     cout<<_weighted_A[i]<<endl;    \n        // }\n        \n        for(int i = 0; i<_JDOF; i++)\n        {\n            returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n            returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n            returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n\n            _q_des[i] = returnArray[i];\n            _qdot_des[i] = returnArray[_JDOF+i];\n        }\n    }\n}\n\nvoid CudaTest::load_weight()\n{\n    #if _nodes_cuda == 32\n    {\n        for(int i = 0; i<6; i++)\n        {\n            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n        }\n    }\n    #elif _nodes_cuda == 64\n    {\n        for(int i = 0; i<6; i++)\n        {\n            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n        } \n    }\n    #elif _nodes_cuda == 100\n    {\n        for(int i = 0; i<6; i++)\n        {\n            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n        } \n    }\n    #else\n    #endif\n    \n    weight0.open(filename_NN[0].str());\n    for(int i = 0; i<_JDOF ; i++)\n    {\n        for(int j = 0; j<_nodes_cuda ; j++)\n        {\n            weight0 >> weights0[i*_nodes_cuda + j];\n        }\n    }\n    weight0.close();\n    \n    weight0.open(filename_NN[1].str());\n    for(int i = 0; i<_nodes_cuda ; i++)\n    {\n        weight0 >> weights1[i];\n    }\n    weight0.close();\n\n    weight0.open(filename_NN[2].str());\n    for(int i = 0; i<_nodes_cuda ; i++)\n    {\n        for(int j = 0; j<_nodes_cuda ; j++)\n        {\n            weight0 >> weights2[i*_nodes_cuda + j];\n        }\n    }\n    weight0.close();\n\n    weight0.open(filename_NN[3].str());\n    for(int i = 0; i<_nodes_cuda ; i++)\n    {\n        weight0 >> weights3[i];\n    }\n    weight0.close();\n\n    weight0.open(filename_NN[4].str());\n    for(int i = 0; i<_nodes_cuda ; i++)\n    {\n        weight0 >> weights4[i];\n    }\n    weight0.close();\n    weight0.open(filename_NN[5].str());\n    weight0 >> weights5[0];\n    weight0.close();\n}\n\nvoid CudaTest::cpu_memory_save()\n{\n    cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n    memset(cost_jointlimit, 0, N * sizeof(double));\n    memset(_mean_matrix, 0, N * sizeof(double));\n    memset(d, 0, N * sizeof(double));\n    memset(e, 0, N * sizeof(double));\n    memset(f, 0, N * sizeof(double));\n    memset(_matrix_for_cuda, 0, N * sizeof(double));\n\n    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n\n    memset(FK_d, 0, 9 * sizeof(double));\n    memset(FK_a, 0, 9 * sizeof(double));\n    memset(FK_alpha, 0, 9 * sizeof(double));\n    \n    memset(_return_cost, 0, _sampling_num * sizeof(double));\n    memset(_cost, 0, _sampling_num * sizeof(double));\n\n    memset(_max_joint_position, 0, _JDOF * sizeof(double));\n    memset(_min_joint_position, 0, _JDOF * sizeof(double));\n    memset(_q_des, 0, _JDOF * sizeof(double));\n    memset(_qdot_des, 0, _JDOF * sizeof(double));\n    memset(_A, 0, _JDOF * sizeof(double));\n    memset(_weighted_A, 0, _JDOF * sizeof(double));\n    memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n    memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n    \n    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n    memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n    memset(weights1, 0, _nodes_cuda * sizeof(double));\n    memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n    memset(weights3, 0, _nodes_cuda * sizeof(double));\n    memset(weights4, 0, _nodes_cuda * sizeof(double));\n    // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n    memset(outputs, 0, _sampling_num * sizeof(double));\n    memset(returnArray, 0, _JDOF*3 * sizeof(double));\n\n    memset(_prev_x, 0, 3 * sizeof(double));\n    memset(_prev_r, 0, 3 * sizeof(double));\n\n    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n\n    \n    weights5[0] = 0.0;\n    position_sec1[0] = 0.0;\n    position_sec2[0] = 0.0;\n    velocity_lim[0] = 0.0;\n}\n\nvoid CudaTest::cuda_memory_save()\n{\n    cout<<\":::::::::::::CUDA <GPU> Memory Save:::::::::::::\"<<endl<<endl;\n    cudaMalloc((void**)&dev__A, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev__mean_matrix, N*sizeof(double));\n    cudaMalloc((void**)&dev__matrix_for_cuda, N*sizeof(double));\n    // cudaMalloc((void**)&dev__prev_matrix_for_cuda, N*sizeof(double));\n    cudaMalloc((void**)&dev_states, N*sizeof(double));\n\n    // cudaMalloc((void**)&dev_a, N * sizeof(double));\n    cudaMalloc((void**)&dev_b, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev_c, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev_d, N * sizeof(double));\n    cudaMalloc((void**)&dev_e, N * sizeof(double));\n    cudaMalloc((void**)&dev_cost, N * sizeof(double));\n    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n    cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n    cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n\n    cudaMalloc((void**)&d_weights0, _JDOF * _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights1, _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n\n    cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n    cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n\n    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n    cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n    cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n\n    cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n    cudaMalloc((void**)&dev_joint_max_limit_for_cost, _JDOF * sizeof(double));\n    cudaMalloc((void**)&dev_cen_joint_position, _JDOF * sizeof(double));\n\n    cudaMalloc((void**)&dev_position_sec1, sizeof(double));\n    cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n    cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n\n    // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n\n    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n\n    cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n    cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n\n    cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n    cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n    cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n\n    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n    cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n\n    \n}\n\nvoid CudaTest::cuda_memory_free()\n{    \n    cout<<\":::::::::::::CUDA Memory Free:::::::::::::\"<<endl<<endl;\n    cudaFree(dev__A);\n    cudaFree(dev__mean_matrix);\n    cudaFree(dev__matrix_for_cuda);\n    // cudaFree(dev__prev_matrix_for_cuda);\n    cudaFree(dev_states);\n\n    cudaFree(dev_b);\n    cudaFree(dev_c);\n    cudaFree(dev_d);\n    cudaFree(dev_e);\n    cudaFree(dev_cost);\n    cudaFree(dev_cost_x);\n    \n    cudaFree(dev_q_goal);\n    cudaFree(dev_x_goal);\n    cudaFree(dev_rot_goal);\n    cudaFree(dev_rot_goal_T);\n\n    cudaFree(d_weights0);\n    cudaFree(d_weights1);\n    cudaFree(d_weights2);\n    cudaFree(d_weights3);\n    cudaFree(d_weights4);\n    cudaFree(d_weights5);\n    cudaFree(d_outputs);\n\n    cudaFree(hidden0);\n    cudaFree(hidden1);\n\n    cudaFree(dev_inputs);\n    cudaFree(dev_min_joint_position_for_NN);\n    cudaFree(dev_max_joint_position_for_NN);\n\n    cudaFree(dev_joint_min_limit_for_cost);\n    cudaFree(dev_joint_max_limit_for_cost);\n    cudaFree(dev_cen_joint_position);\n\n    cudaFree(dev_position_sec1);\n    cudaFree(dev_position_sec2);\n    cudaFree(dev_velocity_lim);\n\n    // cudaFree(_dev_jacobian);\n    cudaFree(dev_position_EE);\n    cudaFree(dev_orientation_EE);\n\n    cudaFree(dev_FK_a);\n    cudaFree(dev_FK_d);\n    cudaFree(dev_FK_alpha);\n\n    cudaFree(dev_jacobian);\n    cudaFree(dev_jacobian_transpose);\n\n    cudaError_t error = cudaGetLastError();\n    if (error != cudaSuccess) {\n        printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n        // 에러 처리 로직을 추가해야 합니다.\n    }\n}\n\nvoid CudaTest::initialize()\n{\n    // cout<<endl;\n    cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n    // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n    // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n    // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n\n    // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n    _sol_cost = 0.0;\n\n    position_sec1[0] = 0.03125;\n    position_sec2[0] = 0.005;\n    velocity_lim[0] = 0.8;\n\n    // position_sec1[0] = 0.03125;\n    // position_sec2[0] = 0.00625;\n    // velocity_lim[0] = 1.0;\n\t\n    // numBlocks = N / THREADS_PER_BLOCK;\n    // numBlocks2 = (N / _time_window) / THREADS_PER_BLOCK2;\n\n\n    // panda_arm_hand.urdf // panda_arm_hand.xml model\n\t// _min_joint_position[0] = -2.9671;\n\t// _min_joint_position[1] = -1.8326;\n\t// _min_joint_position[2] = -2.9671;\n\t// _min_joint_position[3] = -3.1416;\n\t// _min_joint_position[4] = -2.9671;\n\t// _min_joint_position[5] = -0.0873;\n\t// _min_joint_position[6] = -2.9671;\n\n\t// _max_joint_position[0] = 2.9671;\n\t// _max_joint_position[1] = 1.8326;\n\t// _max_joint_position[2] = 2.9671;\n\t// _max_joint_position[3] = 0.0;\n\t// _max_joint_position[4] = 2.9671;\n\t// _max_joint_position[5] = 3.8223;\n\t// _max_joint_position[6] = 2.9671;\n\n\n\n    // fr3.urdf // fr3.xml model\n    _min_joint_position[0] = -2.8973;\n\t_min_joint_position[1] = -1.7628;\n\t_min_joint_position[2] = -2.8973;\n\t_min_joint_position[3] = -3.0718;\n\t_min_joint_position[4] = -2.8973;\n\t_min_joint_position[5] = -0.0175;\n\t_min_joint_position[6] = -2.8973;\n\n\t_max_joint_position[0] = 2.8973;\n\t_max_joint_position[1] = 1.7628;\n\t_max_joint_position[2] = 2.8973;\n\t_max_joint_position[3] = -0.0698;\n\t_max_joint_position[4] = 2.8973;\n\t_max_joint_position[5] = 3.7525;\n\t_max_joint_position[6] = 2.8973;\n\n\n\n    //k = 0.1\n    // _hat_min_joint_position[0] = -2.37368;\n    // _hat_max_joint_position[0] = 2.37368;\n\n    // _hat_min_joint_position[1] = -1.46608;\n    // _hat_max_joint_position[1] = 1.46608;\n\n    // _hat_min_joint_position[2] = -2.37368;\n    // _hat_max_joint_position[2] = 2.37368;\n\n    // _hat_min_joint_position[3] = −2.82744;\n    // _hat_max_joint_position[3] = -0.31416;\n\n    // _hat_min_joint_position[4] = -2.37368;\n    // _hat_max_joint_position[4] = 2.37368;\n\n    // _hat_min_joint_position[5] = 0.30366;\n    // _hat_max_joint_position[5] = 3.43134;\n\n    // _hat_min_joint_position[6] = -2.37368;\n    // _hat_max_joint_position[6] = 2.37368;\n\n\n\n    for(int i = 0; i<_JDOF; i++)\n    {\n        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n    }\n\n    FK_a[0] = 0.0;\n    FK_d[0] = 0.343;\n    FK_alpha[0] = 0.0;\n\n    FK_a[1] = 0.0;\n    FK_d[1] = 0.0;\n    FK_alpha[1] = -PI_CUDA/2.0;\n\n    FK_a[2] = 0.0;\n    FK_d[2] = 0.316;\n    FK_alpha[2] = PI_CUDA/2.0;\n\n    FK_a[3] = 0.0825;\n    FK_d[3] = 0.0;\n    FK_alpha[3] = PI_CUDA/2.0;\n\n    FK_a[4] = -0.0825;\n    FK_d[4] = 0.384;\n    FK_alpha[4] = -PI_CUDA/2.0;\n\n    FK_a[5] = 0.0;\n    FK_d[5] = 0.0;\n    FK_alpha[5] = PI_CUDA/2.0;\n\n    FK_a[6] = 0.088;\n    FK_d[6] = 0.0;\n    FK_alpha[6] = PI_CUDA/2.0;\n\n    FK_a[7] = 0.0;\n    FK_d[7] = 0.107;\n    FK_alpha[7] = 0.0;\n\n    FK_a[8] = 0.0;\n    FK_d[8] = 0.1034;\n    FK_alpha[8] = 0.0;\n}"
        }
    ]
}